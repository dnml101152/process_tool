#TODO Shortcuts wieder einbauen
#TODO Bei Finish schon die Antwort speichern auch wenn der Prozess noch nicht beendet wird.
#TODO Load Table so machen, dass man einfach erkennt, was die antworten und todos waren
#TODO Designtables etwas schöner machen

import uuid

import sys
import uuid
from bson import ObjectId
import pprint
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QLabel, QStackedWidget, QGridLayout, QShortcut, QMessageBox,QFrame
)
from PyQt5.QtGui import QFont, QMouseEvent, QKeySequence
from PyQt5.QtCore import Qt, QPoint, QTimer, pyqtSignal
from PyQt5.QtWidgets import (
    QWidget, QLabel, QListWidget, QPushButton,QTableWidgetItem,QSizePolicy,
    QVBoxLayout, QHBoxLayout, QListWidgetItem,QTableWidget, QLineEdit, QDialog, QComboBox, QCheckBox, QScrollArea, QMenu, QAction, QColorDialog,QTextEdit, QTextBrowser
)
from PATH import uri

from pymongo import MongoClient
from datetime import datetime
import ast


class Todo:
    def __init__(self, title=None, checked=False, comment=None):
        self.title = title
        self.checked = checked
        self.comment = comment

    @classmethod
    def from_dict(cls, data):
        if not isinstance(data, dict):
            raise ValueError("Expected dict to create Todo")
        return cls(
            title=data.get('title'),
            checked=data.get('checked', False),
            comment=data.get('comment')
        )

    def to_dict(self):
        return {
            'title': self.title,
            'checked': self.checked,
            'comment': self.comment
        }

class Task:
    def __init__(self, title=None, type_=None, answer=None, comment=None, text=None,
                 task_id=None, process_id=None, hints=None, items=None):
        self.title = title
        self.task_id = str(uuid.uuid4())
        self.type = type_
        self.answer = answer
        self.comment = comment
        self.text = text
        self.task_id = task_id
        self.process_id = process_id
        self.hints = hints if hints is not None else []
        self.items = items if items is not None else []

    @classmethod
    def from_dict(cls, data):
        return cls(
            title=data.get('title'),
            type_=data.get('type'),
            answer=data.get('answer'),
            comment=data.get('comment'),
            text=data.get('text'),
            task_id=data.get('task_id'),
            process_id=data.get('process_id'),
            hints=data.get('hints', []),
            items=data.get('items', [])
        )

    def to_dict(self):
        return {
            'title': self.title,
            'type': self.type,
            'answer': self.answer,
            'comment': self.comment,
            'text': self.text,
            'task_id': self.task_id,
            'process_id': self.process_id,
            'hints': self.hints,
            'items': self.items
        }

    def __repr__(self):
        return (f"Task(title={self.title!r}, type={self.type!r}, answer={self.answer!r}, "
                f"comment={self.comment!r}, text={self.text!r}, task_id={self.task_id!r}, "
                f"process_id={self.process_id!r}, hints={self.hints!r}, items={self.items!r})")

class Process:
    def __init__(self, title=None, tasks=None, todos=None, type_id=None, type_title=None, status=None, process_id=None, start_date=None):
        self.title = title
        self.tasks = tasks if tasks is not None else []
        self.todos = todos if todos is not None else []   # <--- NEW attribute
        self.type_id = type_id
        self.type_title = type_title
        self.status = status
        self.process_id = process_id
        self.start_date = start_date

    @classmethod
    def from_dict(cls, data):
        tasks_data = data.get('tasks', [])
        tasks = [Task.from_dict(td) for td in tasks_data]

        todos_data = data.get('todos', [])
        todos = [Todo.from_dict(td) if isinstance(td, dict) else td for td in todos_data]

        process_id = data.get('process_id')
        start_date = data.get('start_date')
        if isinstance(start_date, str):
            start_date = datetime.fromisoformat(start_date)

        return cls(
            title=data.get('title'),
            tasks=tasks,
            todos=todos,
            type_id=data.get('type_id'),
            type_title=data.get('type_title'),
            status=data.get('status'),
            process_id=process_id,
            start_date=start_date
        )

    def to_dict(self):
        return {
            'title': self.title,
            'tasks': [task.to_dict() for task in self.tasks],
            'todos': [todo.to_dict() for todo in self.todos],
            'type_id': self.type_id,
            'type_title': self.type_title,
            'status': self.status,
            'process_id': self.process_id,
            'start_date': self.start_date.isoformat() if self.start_date else None
        }

    @classmethod
    def from_template(cls, template: 'ProcessTemplate'):
        # Update to include todos if template has it, or initialize empty list
        try:
            if not isinstance(template, ProcessTemplate):
                raise TypeError("Expected a ProcessTemplate instance")

            tasks_copy = [Task.from_dict(task.to_dict()) for task in template.tasks]
            todos_copy = getattr(template, "todos", [])

            return cls(
                title=template.title,
                tasks=tasks_copy,
                todos=todos_copy,  # <--- add todos from template if available
                type_id=template.template_id,
                type_title=template.title,
                status="created",
                process_id=str(uuid.uuid4()),
                start_date=datetime.now()
            )
        except Exception as err:
            print(963, err)

    def __repr__(self):
        return (f"Process(title={self.title!r}, type_id={self.type_id!r}, "
                f"type_title={self.type_title!r}, status={self.status!r}, "
                f"tasks={self.tasks!r}, todos={self.todos!r})")


    def start(self):
        if self.status in ["created", "paused"]:
            self.status = "running"
        else:
            raise RuntimeError(f"Cannot start a process in status '{self.status}'")

    def end(self):
        if self.status == "running":
            self.status = "completed"
        else:
            raise RuntimeError(f"Cannot end a process that is not running")


    def kill(self):
        if self.status in ["running", "paused"]:
            self.status = "terminated"
        else:
            raise RuntimeError(f"Cannot kill a process in status '{self.status}'")

    def save(self,process_collection):
        data = self.to_dict()
        # Use process_id as _id if it exists to update, else insert new
        if self.process_id:
            result = process_collection.replace_one(
                {"process_id": self.process_id},
                data,
                upsert=True
            )
        else:
            # Assign new process_id and insert
            self.process_id = str(uuid.uuid4())
            data['process_id'] = self.process_id
            result = process_collection.insert_one(data)
        print(f"Process saved with process_id={self.process_id}")

# class ProcessTemplate:
#     def __init__(self, title=None, template_id=None, tasks=None, todos=None):
#         self.title = title
#         self.template_id = str(uuid.uuid4())
#         self.tasks = tasks if tasks is not None else []
#         self.todos = todos if todos is not None else []
#
#     @classmethod
#     def from_dict(cls, data):
#         tasks_data = data.get('tasks', [])
#         todos_data = data.get('todos', [])
#
#         return cls(
#             title=data.get('title'),
#             template_id=data.get('template_id'),
#             tasks=[Task.from_dict(t) for t in tasks_data],
#             #TODO hier noch einbauen, nachdem ich die Klasse angelegt habe
#             #todos=[Todo.from_dict(td) for td in todos_data],
#         )
#
#     def to_dict(self):
#         return {
#             'title': self.title,
#             'template_id': self.template_id,
#             'tasks': self.tasks,
#             'todos': self.todos
#         }
#
#     def save_to_mdb(self, mdb_collection):
#         print("Saving to MongoDB...")
#
#         output = self.to_dict()
#         output["tasks"] = [task.to_dict() for task in self.tasks]
#         output["todos"] = [todo.to_dict() for todo in self.todos]
#
#         result = mdb_collection.update_one(
#             {"template_id": self.template_id},  # match on template_id
#             {"$set": output},  # update fields
#             upsert=True  # insert if not exists
#         )
#
#         if result.upserted_id:
#             print(f"Inserted new template with _id: {result.upserted_id}")
#         else:
#             print("Updated existing template.")
#
#
#     def __repr__(self):
#         return (f"ProcessTemplate(title={self.title!r}, template_id={self.template_id!r}, "
#                 f"tasks={self.tasks!r}, todos={self.todos!r})")


class ProcessTemplate:
    def __init__(self, title=None, template_id=None, tasks=None, todos=None, button_position=(0, 0), button_color="#FFFFFF"):
        self.title = title
        self.template_id = template_id or str(uuid.uuid4())
        self.tasks = tasks if tasks is not None else []
        self.todos = todos if todos is not None else []
        self.button_position = button_position  # tuple of two ints
        self.button_color = button_color        # string representing color

    @classmethod
    def from_dict(cls, data):
        tasks_data = data.get('tasks', [])
        todos_data = data.get('todos', [])
        button_position = tuple(data.get('button_position', (0, 0)))
        button_color = data.get('button_color', "#FFFFFF")

        return cls(
            title=data.get('title'),
            template_id=data.get('template_id'),
            tasks=[Task.from_dict(t) for t in tasks_data],
            todos=[Todo.from_dict(td) for td in todos_data],
            button_position=button_position,
            button_color=button_color
        )

    def to_dict(self):
        return {
            'title': self.title,
            'template_id': self.template_id,
            'tasks': [task.to_dict() for task in self.tasks],
            'todos': [todo.to_dict() for todo in self.todos],
            'button_position': self.button_position,
            'button_color': self.button_color
        }

    def save_to_mdb(self, mdb_collection):
        print("Saving to MongoDB...")
        result = mdb_collection.update_one(
            {"template_id": self.template_id},
            {"$set": self.to_dict()},
            upsert=True
        )

        if result.upserted_id:
            print(f"Inserted new template with _id: {result.upserted_id}")
        else:
            print("Updated existing template.")

    def __repr__(self):
        return (f"ProcessTemplate(title={self.title!r}, template_id={self.template_id!r}, "
                f"tasks={self.tasks!r}, todos={self.todos!r}, "
                f"button_position={self.button_position!r}, button_color={self.button_color!r})")

class TaskWidget(QFrame):
    def __init__(self, todo: Todo, select_callback=None):
        super().__init__()
        self.todo = todo
        self.select_callback = select_callback
        self.setFrameShape(QFrame.StyledPanel)
        self.setObjectName("taskFrame")
        self.set_default_style()
        self.selected = False

        main_layout = QVBoxLayout()
        main_layout.setSpacing(5)

        top_layout = QHBoxLayout()
        self.checkbox = QCheckBox()
        self.checkbox.setFixedSize(20, 20)
        self.checkbox.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.checkbox.setChecked(self.todo.checked)
        self.update_style(self.checkbox.checkState())
        self.checkbox.stateChanged.connect(self.update_style)

        self.label = QLabel(self.todo.title)
        self.label.setWordWrap(True)

        top_layout.addWidget(self.checkbox)
        top_layout.addWidget(self.label)
        top_layout.addStretch()
        main_layout.addLayout(top_layout)

        self.comment = QTextEdit()
        self.comment.setPlainText(self.todo.comment)
        self.comment.setPlaceholderText("Add a comment...")
        self.comment.setFixedHeight(60)
        self.comment.textChanged.connect(self.sync_comment)

        main_layout.addWidget(self.comment)
        self.setLayout(main_layout)

    def sync_comment(self):
        self.todo.comment = self.comment.toPlainText()

    def set_default_style(self):
        self.setStyleSheet("""
            QFrame#taskFrame {
                border: 1px solid #ccc;
                border-radius: 8px;
                padding: 8px;
                margin-bottom: 10px;
                background-color: #f9f9f9;
            }
            QLabel {
                font-size: 14px;
                color: black;
                text-decoration: none;
            }
            QTextEdit {
                font-size: 12px;
            }
        """)

    def set_selected_style(self):
        self.setStyleSheet("""
            QFrame#taskFrame {
                border: 2px solid #0078d7;
                border-radius: 8px;
                padding: 7px;
                margin-bottom: 10px;
                background-color: #e6f0fa;
            }
            QLabel {
                font-size: 14px;
                color: black;
                text-decoration: none;
            }
            QTextEdit {
                font-size: 12px;
            }
        """)

    def set_completed_style(self):
        self.setStyleSheet("""
            QFrame#taskFrame {
                border: 1px solid #3c9;
                border-radius: 8px;
                padding: 8px;
                margin-bottom: 10px;
                background-color: #e6ffe6;
            }
            QLabel {
                font-size: 14px;
                color: gray;
                text-decoration: line-through;
            }
            QTextEdit {
                font-size: 12px;
            }
        """)

    def update_style(self, state):
        self.todo.checked = (state == Qt.Checked)
        if self.todo.checked:
            self.set_completed_style()
        else:
            if self.selected:
                self.set_selected_style()
            else:
                self.set_default_style()

    def mousePressEvent(self, event):
        if self.select_callback:
            self.select_callback(self)
        event.accept()

    def set_selected(self, selected: bool):
        self.selected = selected
        self.update_style(self.checkbox.checkState())

    def contextMenuEvent(self, event):
        menu = QMenu(self)

        edit_action = QAction("Edit", self)
        delete_action = QAction("Delete", self)

        menu.addAction(edit_action)
        menu.addAction(delete_action)

        # Connect actions to their respective methods
        edit_action.triggered.connect(self.on_edit)
        delete_action.triggered.connect(self.on_delete)

        menu.exec_(event.globalPos())

    def on_edit(self):
        class TaskEditDialog(QDialog):
            def __init__(self, todo, parent=None):
                super().__init__(parent)
                self.setWindowTitle("Edit Task")
                self.todo = todo

                layout = QVBoxLayout()

                layout.addWidget(QLabel("Title:"))
                self.title_edit = QLineEdit(todo.title)
                layout.addWidget(self.title_edit)

                layout.addWidget(QLabel("Comment:"))
                self.comment_edit = QTextEdit(todo.comment)
                layout.addWidget(self.comment_edit)

                save_btn = QPushButton("Save")
                save_btn.clicked.connect(self.save)
                layout.addWidget(save_btn)

                self.setLayout(layout)

            def save(self):
                self.todo.title = self.title_edit.text()
                self.todo.comment = self.comment_edit.toPlainText()
                self.accept()

        dialog = TaskEditDialog(self.todo, self)
        if dialog.exec_() == QDialog.Accepted:
            self.label.setText(self.todo.title)
            self.comment.setPlainText(self.todo.comment)

    def on_delete(self,list):
        from PyQt5.QtWidgets import QMessageBox

        reply = QMessageBox.question(
            self,
            "Delete Task",
            f"Are you sure you want to delete the task '{self.todo.title}'?",
            QMessageBox.Yes | QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            # If you have a callback to notify the container to delete this task:
            if hasattr(self, 'delete_callback') and callable(self.delete_callback):
                self.delete_callback(self)
            else:
                # Just hide or disable if no callback
                self.setDisabled(True)
                self.hide()
class TodoApp(QWidget):
    todo_changed = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setWindowTitle("To-Do App")
        self.setGeometry(100, 100, 400, 600)

        main_layout = QVBoxLayout(self)

        self.task_input = QLineEdit()
        self.task_input.setPlaceholderText("Enter a new task...")

        self.add_button = QPushButton("Add Task")
        self.add_button.clicked.connect(self.add_task)

        self.task_area = QScrollArea()
        self.task_area.setWidgetResizable(True)

        self.task_container = QWidget()
        self.task_layout = QVBoxLayout(self.task_container)
        self.task_area.setWidget(self.task_container)

        btn_layout = QHBoxLayout()
        self.up_button = QPushButton("Move Up ▲")
        self.down_button = QPushButton("Move Down ▼")
        btn_layout.addWidget(self.up_button)
        btn_layout.addWidget(self.down_button)

        self.up_button.clicked.connect(self.move_selected_up)
        self.down_button.clicked.connect(self.move_selected_down)

        main_layout.addWidget(self.task_input)
        main_layout.addWidget(self.add_button)
        main_layout.addWidget(self.task_area)
        main_layout.addLayout(btn_layout)

        self.selected_task = None
        self.update_buttons_state()

    def add_task(self):
        task_text = self.task_input.text().strip()
        if task_text:
            todo = Todo(title=task_text)
            task_widget = TaskWidget(todo, self.select_task)
            task_widget.delete_callback = self.delete_task_widget
            task_widget.setParent(self.task_container)
            self.task_layout.addWidget(task_widget)
            self.task_input.clear()
            self.select_task(task_widget)
            self.todo_changed.emit()

    def delete_task_widget(self, task_widget):
        # Remove widget from layout & UI
        self.task_layout.removeWidget(task_widget)
        task_widget.setParent(None)
        task_widget.deleteLater()

        # Remove from internal data if you keep track:
        # If you have a list of todos, remove this todo:
        # For example, if you keep a separate list:
        # self.todos.remove(task_widget.todo)

        # If you rely on the UI for data, just update selection/buttons:
        if self.selected_task == task_widget:
            self.selected_task = None
        self.update_buttons_state()
        self.todo_changed.emit()

    def scroll_to_task(self, task_widget):
        if not task_widget:
            return
        # scroll area is self.task_area
        area = self.task_area

        # Map task_widget's position relative to the scroll area
        pos = task_widget.mapTo(area.widget(), QPoint(0, 0))
        area.verticalScrollBar().setValue(pos.y())

    def check_selected_task(self, checked=True):
        if self.selected_task:
            self.selected_task.checkbox.setChecked(checked)
            # Optionally emit signal if needed
            #self.todo_changed.emit()

    def select_task(self, task_widget):
        if self.selected_task:
            self.selected_task.set_selected(False)
        self.selected_task = task_widget
        if task_widget:
            task_widget.set_selected(True)
        self.update_buttons_state()

    def select_next_unchecked_task(self):
        layout = self.task_layout
        count = layout.count()

        # Collect all task widgets
        task_widgets = [
            layout.itemAt(i).widget()
            for i in range(count)
            if isinstance(layout.itemAt(i).widget(), TaskWidget)
        ]

        # Find unchecked ones
        unchecked_tasks = [w for w in task_widgets if not w.checkbox.isChecked()]

        if not unchecked_tasks:
            return None  # no unchecked tasks

        # If no selection, select the first unchecked
        if self.selected_task is None:
            self.select_task(unchecked_tasks[0])
            return unchecked_tasks[0]

        # If selection exists, find the next unchecked after it
        try:
            current_index = task_widgets.index(self.selected_task)
        except ValueError:
            current_index = -1

        # Look for the next unchecked task after current
        for w in unchecked_tasks:
            if task_widgets.index(w) > current_index:
                self.select_task(w)
                return w

        # If none found after current, loop to first unchecked
        self.select_task(unchecked_tasks[0])
        return unchecked_tasks[0]

    def move_selected_up(self):
        if not self.selected_task:
            return
        layout = self.task_layout
        index = layout.indexOf(self.selected_task)
        if index > 0:
            layout.removeWidget(self.selected_task)
            layout.insertWidget(index - 1, self.selected_task)
            self.select_task(self.selected_task)
            self.todo_changed.emit()

    def move_selected_down(self):
        if not self.selected_task:
            return
        layout = self.task_layout
        index = layout.indexOf(self.selected_task)
        count = layout.count()
        if index < count - 1:
            layout.removeWidget(self.selected_task)
            layout.insertWidget(index + 1, self.selected_task)
            self.select_task(self.selected_task)
            self.todo_changed.emit()

    def update_buttons_state(self):
        if not self.selected_task:
            self.up_button.setEnabled(False)
            self.down_button.setEnabled(False)
            return
        layout = self.task_layout
        index = layout.indexOf(self.selected_task)
        count = layout.count()
        self.up_button.setEnabled(index > 0)
        self.down_button.setEnabled(index < count - 1)

    def load_tasks_from_dict(self, todos_data):

        self.clear_tasks()
        for todo_dict in todos_data:
            todo = Todo.from_dict(todo_dict)
            task_widget = TaskWidget(todo, self.select_task)
            task_widget.delete_callback = self.delete_task_widget

            task_widget.setParent(self.task_container)
            self.task_layout.addWidget(task_widget)
        self.update_buttons_state()

    def get_tasks_as_dict(self):
        tasks = []
        for i in range(self.task_layout.count()):
            item = self.task_layout.itemAt(i)
            widget = item.widget()
            if isinstance(widget, TaskWidget):
                widget.sync_comment()
                tasks.append(widget.todo.to_dict())
        return tasks

    def clear_tasks(self):
        while self.task_layout.count():
            item = self.task_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.setParent(None)
                widget.deleteLater()
        self.selected_task = None
        self.update_buttons_state()

    def set_todos(self, todo_list: list[Todo]):
        self.clear_tasks()
        for todo in todo_list:
            task_widget = TaskWidget(todo, self.select_task)
            task_widget.setParent(self.task_container)
            task_widget.delete_callback = self.delete_task_widget

            self.task_layout.addWidget(task_widget)
        self.update_buttons_state()

    def get_todos(self) -> list[Todo]:
        todos = []
        for i in range(self.task_layout.count()):
            item = self.task_layout.itemAt(i)
            widget = item.widget()
            if isinstance(widget, TaskWidget):
                widget.sync_comment()
                todos.append(widget.todo)
        return todos

    def is_valid(self):
        for i in range(self.task_layout.count()):
            item = self.task_layout.itemAt(i)
            widget = item.widget()
            if isinstance(widget, TaskWidget):
                # Assuming TaskWidget has an attribute 'check_button' that is a QCheckBox
                if not widget.checkbox.isChecked():
                    return False
        return True

class SelectionDialog(QDialog):
    def __init__(self, items, parent=None, title="Select an Option", label="Choose one:"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.selected_item = None


        layout = QVBoxLayout(self)

        layout.addWidget(QLabel(label))

        self.combo_box = QComboBox()
        # Populate combo with title as display, full dict as user data
        for process in items:
            self.combo_box.addItem(process.title, process)

        layout.addWidget(self.combo_box)

        # Buttons
        button_layout = QHBoxLayout()
        confirm_button = QPushButton("Confirm")
        cancel_button = QPushButton("Cancel")
        button_layout.addWidget(confirm_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        confirm_button.clicked.connect(self.confirm)
        cancel_button.clicked.connect(self.reject)

    def confirm(self):
        self.selected_item = self.combo_box.currentData()
        self.accept()

    def get_selection(self):
        return self.selected_item


class RightClickableButton(QPushButton):
    def __init__(self,main,button_pos,load_color = None,load_id = None, text="", parent=None):
        super().__init__(text, parent)

        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self.main = main
        self.color = None
        self.button_pos = button_pos
        self.button_template = None

        if load_id:
            self.id = load_id
            self.update_button()
        else:
            self.id = None
        if load_color:
            self.color = load_color
            self.update_button()
        self.prior_id = None


    def show_context_menu(self, pos: QPoint):
        global_pos = self.mapToGlobal(pos)

        menu = QMenu(self)

        action_1 = QAction("Set Quicklink", self)
        action_1.triggered.connect(self.set_quicklink)

        action_2 = QAction("Custom Action 2", self)
        action_2.triggered.connect(self.get_color)

        menu.addAction(action_1)
        menu.addAction(action_2)

        menu.exec_(global_pos)

    def set_quicklink(self):
        try:
            if self.id:
                self.prior_id = self.id
            dialog = SelectionDialog(self.main.templates,self.main, title="Pick Quicklink for button")
            if dialog.exec_() == QDialog.Accepted:
                self.ql_process= dialog.get_selection()
                self.id = dialog.get_selection()
                self.ql_process.button_position = self.button_pos
                self.button_template = dialog.get_selection()
                self.main.process_collection.update_one(
                         {"template_id": self.button_template.template_id},
                         {"$set": {"button_position":self.button_template.button_position,"button_color":self.button_template.button_color}},
                         upsert=True
                     )
                # self.color = None
                #
                # if self.prior_id:
                #     del self.main.process_data[self.prior_id]["button_position"]
                #     del self.main.process_data[self.prior_id]["button_color"]
                #     self.main.process_collection.update_many(
                #         {"idkey": self.prior_id},
                #         {"$unset": {"button_position": "", "button_color": ""}}
                #     )
                self.update_button()


            else:
                print("Cancelled")
        except Exception as err:
            print(err)

    def get_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.color = color.name()
            self.button_template.button_color = self.color
            self.main.process_collection.update_one(
                {"template_id": self.button_template.template_id},
                {"$set": {"button_position": self.button_template.button_position,
                          "button_color": self.button_template.button_color}},
                upsert=True
            )
            self.update_button()


            return None  # Returns color as hex string, e.g. "#ff0000"
        return None

    def update_button(self):
        if self.button_template:
            self.setText(self.button_template.title)
            self.setStyleSheet(f"background-color: {self.color}")
            try:
                self.clicked.disconnect()
            except TypeError:
                # no connections were present
                pass
            self.clicked.connect(lambda: self.main.run_process_from_template(self.button_template))


        #self.layout()

#TODO List Widget links einbauen

# --- Sub-check widget with simple QCheckBox ---
class Subcheck(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        main_layout = QVBoxLayout(self)

        # Horizontal layout: checkbox + label
        top_row = QHBoxLayout()
        self.check_box = QCheckBox()
        self.check_box.setFixedSize(20, 20)

        self.check_box.stateChanged.connect(self.notify_parent)
        top_row.addWidget(self.check_box)

        self.check_label = QLabel("Check item:")
        self.check_label.setStyleSheet("font-size: 14pt;")
        self.check_box.setStyleSheet("""
            QCheckBox::indicator {
                width: 28px;
                height: 28px;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;  /* Green */
                border: 1px solid #388E3C;
            }
            QCheckBox::indicator:unchecked {
                background-color: white;
                border: 1px solid #888;
            }
        """)
        self.check_label.setAlignment(Qt.AlignVCenter | Qt.AlignLeft)
        top_row.addWidget(self.check_label)

        top_row.addStretch()
        main_layout.addLayout(top_row)

        # Optional comment input
        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        main_layout.addWidget(self.comment_input)



    def notify_parent(self):
        if self.parent() and hasattr(self.parent(), "evaluate_progress"):
            self.parent().evaluate_progress()

    def get_data(self):
        return {
            "text": self.check_label.text(),
            "checked": self.check_box.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_box.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_box.setChecked(False)
        self.comment_input.clear()

# --- Checklist Manager Widget ---
class ChecklistManagerWidget(QWidget):
    def __init__(self, multicheck_input=None):
        super().__init__()
        self.setWindowTitle("Checklist Manager")
        self.setMinimumSize(400, 500)
        self.checks = []

        self.layout = QVBoxLayout(self)

        # Label to show current checklist title or prompt
        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        self.layout.addWidget(self.check_label)

        # Input area with button to add new check item
        add_layout = QHBoxLayout()
        self.check_input = QLineEdit()
        self.check_input.setPlaceholderText("Enter new check...")
        self.add_button = QPushButton("Add Check")
        self.add_button.clicked.connect(self.add_check)
        add_layout.addWidget(self.check_input)
        add_layout.addWidget(self.add_button)
        self.layout.addLayout(add_layout)

        # Scrollable container for check items (Subcheck widgets)
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.checks_container = QWidget()
        self.checks_layout = QVBoxLayout(self.checks_container)
        self.scroll_area.setWidget(self.checks_container)
        self.layout.addWidget(self.scroll_area)

        # Shortcuts for focusing input and confirming add
        focus_shortcut = QShortcut(QKeySequence("Alt+A"), self)
        focus_shortcut.activated.connect(self.check_input.setFocus)

        confirm_shortcut = QShortcut(QKeySequence("Alt+Return"), self)
        confirm_shortcut.activated.connect(self.add_check)

        # Add keyboard shortcut: Ctrl+Shift+C
        self.shortcut_check_first_unchecked = QShortcut(QKeySequence("Ctrl+Shift+C"), self)
        self.shortcut_check_first_unchecked.activated.connect(self.check_first_unchecked)

    def check_first_unchecked(self):
        for subcheck in self.checks:
            if not subcheck.check_box.isChecked():
                subcheck.check_box.setChecked(True)
                break

    def add_check(self):
        """
        Adds a new check item to the checklist if input text is not empty.
        Prevents adding empty or whitespace-only checks.
        """
        text = self.check_input.text()
        if text is None:
            # Defensive: text should not be None, but handle gracefully
            return
        text = text.strip()
        if not text:
            # Do not add empty checks
            return

        # Create new Subcheck widget and set its text safely
        try:
            widget = Subcheck(self.checks_container)
            if hasattr(widget, "set_check_text"):
                widget.set_check_text(text)
            else:
                # Defensive fallback: if Subcheck lacks method, skip adding
                return
        except Exception as e:
            print(f"Error creating or setting Subcheck widget: {e}")
            return

        # Add widget to layout and tracking list
        self.checks_layout.addWidget(widget)
        self.checks.append(widget)

        # Clear input field after adding
        self.check_input.clear()

        # Optionally, update validation state
        self.is_valid()

    def is_valid(self):
        """
        Returns True if all check widgets are valid.
        Empty checklist is considered valid by design.
        """
        if not self.checks:
            return True
        try:
            # Ensure all check widgets implement is_valid method and return True
            return all(
                (hasattr(check, "is_valid") and callable(check.is_valid) and check.is_valid())
                for check in self.checks
            )
        except Exception as e:
            print(f"Error validating checks: {e}")
            return False

    def get_data(self):
        """
        Returns a list of data collected from all Subcheck widgets.
        Returns empty list if no checks or on error.
        """
        try:
            return [
                check.get_data() if (hasattr(check, "get_data") and callable(check.get_data)) else None
                for check in self.checks
            ]
        except Exception as e:
            print(f"Error getting data from checks: {e}")
            return []

    def set_check_text(self, text):
        """
        Sets the checklist title or label text.
        """
        if text is None:
            text = ""
        self.check_label.setText(str(text))

    def reset(self):
        """
        Removes all Subcheck widgets and clears the checklist.
        """
        # Remove widgets safely
        for check in self.checks:
            try:
                check.setParent(None)
                check.deleteLater()
            except Exception as e:
                print(f"Error removing check widget: {e}")

        # Clear internal list of check widgets
        self.checks.clear()

        # Clear input text field
        self.check_input.clear()

        # Update layout to reflect changes
        self.checks_layout.update()

    def load_checks(self, checks_list):
        """
        Loads a list of checks into the widget, replacing existing checks.
        Expects checks_list to be a list of strings; ignores invalid data.
        """
        self.reset()

        # Defensive check for input type
        if not isinstance(checks_list, list):
            print("load_checks expects a list of strings")
            return

        # Add each check text safely
        for text in checks_list:
            if not isinstance(text, str):
                # Skip non-string items to avoid errors
                continue
            try:
                widget = Subcheck(self.checks_container)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
                else:
                    continue
                self.checks_layout.addWidget(widget)
                self.checks.append(widget)
            except Exception as e:
                print(f"Error adding Subcheck in load_checks: {e}")



#TODO neuer fenster bestandteil, wo man die einzelnen
#TODO Final View machen, wo alles zusammengefasst wird und eine möglichkeit für ein Exitbriefing gegeben wird

class DoubleClickCheckButton(QPushButton):
    def __init__(self, text=""):
        super().__init__(text)
        self.setCheckable(True)
        self.setMinimumHeight(80)
        self.setStyleSheet("background-color: none")

    def mousePressEvent(self, event: QMouseEvent):
        # Prevent single clicks from toggling
        event.ignore()

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        # Only toggle on double-click
        self.setChecked(not self.isChecked())
        self.update_style()

    def update_style(self):
        if self.isChecked():
            self.setStyleSheet("background-color: lightgreen")
        else:
            self.setStyleSheet("background-color: none")
class QuestionStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.question_label = QLabel("Question goes here")
        self.question_label.setAlignment(Qt.AlignCenter)
        self.question_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.question_label)

        self.answer_input = QLineEdit()
        self.answer_input.setPlaceholderText("Your answer (required)")
        layout.addWidget(self.answer_input)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        self.answer_input.setFocus()

    def get_data(self):
        return {
            "answer": self.answer_input.text().strip(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return bool(self.answer_input.text().strip())

    def set_question_text(self, text):
        self.question_label.setText(text)
        self.answer_input.clear()
        self.comment_input.clear()

class CheckStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.check_label)

        self.check_button = DoubleClickCheckButton("Check Off")
        layout.addWidget(self.check_button)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        # Ctrl + Space shortcut to toggle check
        toggle_shortcut = QShortcut(QKeySequence("Ctrl+Space"), self)
        toggle_shortcut.activated.connect(self.toggle_check_button)

    def toggle_check_button(self):
        self.check_button.setChecked(not self.check_button.isChecked())
        self.check_button.update_style()

    def get_data(self):
        return {
            "checked": self.check_button.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_button.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_button.setChecked(False)
        self.check_button.update_style()
        self.comment_input.clear()

#
# class RunProcessWidget(QWidget):
#     def __init__(self, main):
#         super().__init__()
#         self.main = main
#         self.pending_process = None
#         self.process_id = None
#         self.current_index = 0
#         self.process_data = None
#         self.process_tracking = None
#         self.step_widgets = {}
#
#
#         # === Outer Layout: Main content (left) + Hints (right) ===
#         outer_layout = QHBoxLayout(self)
#         self.setLayout(outer_layout)
#
#         # === Left Main Content Area ===
#         main_layout = QVBoxLayout()
#         main_container = QWidget()
#         main_container.setLayout(main_layout)
#         outer_layout.addWidget(main_container, 3)  # Stretch factor 3 for main area
#
#         self.title_label = QLabel("Run Process")
#         self.title_label.setFont(QFont("Arial", 16, QFont.Bold))
#         self.title_label.setAlignment(Qt.AlignCenter)
#         main_layout.addWidget(self.title_label)
#
#         self.sub_label = QLabel("Step will show here")
#         self.sub_label.setFont(QFont("Arial", 12))
#         self.sub_label.setAlignment(Qt.AlignCenter)
#         main_layout.addWidget(self.sub_label)
#
#         self.step_container = QStackedWidget()
#         main_layout.addWidget(self.step_container)
#
#         self.widgets_by_type = {
#             "question": QuestionStepWidget(),
#             "check": CheckStepWidget(),
#             "subcheck": ChecklistManagerWidget(),
#             "multicheck": ChecklistManagerWidget()
#         }
#
#         for widget in self.widgets_by_type.values():
#             self.step_container.addWidget(widget)
#
#         nav_layout = QHBoxLayout()
#         self.cancel_button = QPushButton("Cancel")
#         self.cancel_button.clicked.connect(self.cancel_process)
#         nav_layout.addWidget(self.cancel_button)
#
#         self.back_button = QPushButton("Back")
#         self.back_button.clicked.connect(self.go_back)
#         nav_layout.addWidget(self.back_button)
#
#         self.next_button = QPushButton("Next")
#         self.next_button.clicked.connect(self.go_next_or_finish)
#         nav_layout.addWidget(self.next_button)
#
#         # Add keyboard shortcuts
#         QShortcut(QKeySequence("Ctrl+Return"), self, self.next_button.click)
#         QShortcut(QKeySequence("Ctrl+Backspace"), self, self.back_button.click)
#
#         main_layout.addLayout(nav_layout)
#
#         # === Right Side: Hints Panel ===
#         self.hints_browser = QTextBrowser()
#         self.hints_browser.setMinimumWidth(250)
#         self.hints_browser.setStyleSheet("background-color: #f7f7f7; padding: 10px; font-size: 11pt;")
#         self.hints_browser.setOpenExternalLinks(True)
#         outer_layout.addWidget(self.hints_browser, 1)  # Stretch factor 1 for hints
#
#         # Define static hints per step type
#         self.hint_texts = {
#             "question": "<b>Hint:</b> Read the question carefully before responding.",
#             "check": "<b>Hint:</b> Make sure the stated condition is met.",
#             "subcheck": "<b>Hint:</b> Check each sub-item after reviewing it.",
#             "multicheck": "<b>Hint:</b> Select all applicable items for the current step."
#         }
#
#     def update_view(self):
#         print("update_view called")
#
#         if not self.process or not hasattr(self.process, "tasks") or not self.process.tasks:
#             print("No process or no tasks to show.")
#             return
#
#         if self.current_index < 0:
#             self.current_index = 0
#         elif self.current_index >= len(self.process.tasks):
#             self.current_index = len(self.process.tasks) - 1
#
#         task = self.process.tasks[self.current_index]
#         print(f"Current task: {task}")
#
#         task_type = getattr(task, "type", None)
#         task_text = getattr(task, "text", "No text")
#         print(f"Task type: {task_type}")
#         print(f"Task text: {task_text}")
#
#         widget = self.widgets_by_type.get(task_type)
#         print(f"Widget for task type '{task_type}': {widget}")
#         if not widget:
#             print(f"No widget registered for task type '{task_type}'")
#             return
#
#         if self.step_container.indexOf(widget) == -1:
#             print(f"Adding widget for '{task_type}' to step_container")
#             self.step_container.addWidget(widget)
#
#         try:
#             if task_type == "question" and hasattr(widget, "set_question_text"):
#                 print("Calling set_question_text")
#                 widget.set_question_text(task_text)
#             else:
#                 print(f"No handler for task type {task_type}")
#         except Exception as e:
#             print(f"Error updating widget: {e}")
#             return
#
#         print("Setting current widget in step_container")
#         self.step_container.setCurrentWidget(widget)
#
#         if hasattr(self, "step_label"):
#             self.step_label.setText(f"Step {self.current_index + 1} / {len(self.process.tasks)}")
#
#         hints = getattr(task, "hints", None)
#         html = "<i>No hints for this step.</i>"
#         if hints:
#             if isinstance(hints, list) and hints:
#                 html = "<b>Hints:</b><br>" + "<br>".join(f"&bull; {hint}" for hint in hints)
#             elif isinstance(hints, str) and hints.strip():
#                 html = f"<b>Hint:</b> {hints.strip()}"
#
#         if hasattr(self, "hints_browser"):
#             self.hints_browser.setHtml(html)
#
#         print("update_view finished successfully")
#     def go_next_or_finish(self):
#         """
#         Validate current step, store result, and advance to next or finish.
#         """
#         steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
#         if not steps or not (0 <= self.current_index < len(steps)):
#             print("Invalid process state.")
#             return
#
#         current_step = steps[self.current_index]
#         if not isinstance(current_step, dict):
#             print("Malformed step.")
#             return
#
#         step_type = current_step.get("type")
#         widget = self.widgets_by_type.get(step_type)
#         if not widget or not callable(getattr(widget, "is_valid", None)) or not widget.is_valid():
#             print("Invalid input for current step.")
#             return
#
#         if self.process_tracking is None:
#             self.process_tracking = {"responses": []}
#
#         try:
#             data = widget.get_data() if callable(getattr(widget, "get_data", None)) else None
#         except Exception as e:
#             print(f"Error retrieving widget data: {e}")
#             return
#
#         self.process_tracking["responses"].append({
#             "step": self.current_index,
#             "type": step_type or "",
#             "data": data
#         })
#
#         self.current_index += 1
#
#         if self.current_index < len(steps):
#             self.update_view()
#         else:
#             # Finalize process
#             self.process_tracking["status"] = "Completed"
#             self.process_tracking["end_time"] = datetime.now()
#             self.process_tracking["complete"] = True
#             try:
#                 if hasattr(self.main, "answer_collection"):
#                     self.main.answer_collection.insert_one(self.process_tracking)
#             except Exception as e:
#                 print(f"Error saving to DB: {e}")
#
#             try:
#                 if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
#                     self.main.stacked.setCurrentWidget(self.main.grid_widget)
#             except Exception as e:
#                 print(f"Error switching to grid widget: {e}")
#
#     def go_next_or_finish(self):
#         steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
#         if not steps or not (0 <= self.current_index < len(steps)):
#             print("Invalid process state.")
#             return
#
#         current_step = steps[self.current_index]
#         if not isinstance(current_step, dict):
#             print("Malformed step.")
#             return
#
#         step_type = current_step.get("type")
#         widget = self.widgets_by_type.get(step_type)
#         if not widget or not callable(getattr(widget, "is_valid", None)) or not widget.is_valid():
#             print("Invalid input for current step.")
#             return
#
#         if self.process_tracking is None:
#             self.process_tracking = {"responses": []}
#
#         try:
#             data = widget.get_data() if callable(getattr(widget, "get_data", None)) else None
#         except Exception as e:
#             print(f"Error retrieving widget data: {e}")
#             return
#
#         # Prepare the new response for this step
#         new_response = {
#             "step": self.current_index,
#             "type": step_type or "",
#             "data": data
#         }
#
#         responses = self.process_tracking.get("responses", [])
#
#         # Find existing response index for this step, if any
#         existing_idx = next((i for i, r in enumerate(responses) if r.get("step") == self.current_index), None)
#
#         if existing_idx is not None:
#             responses[existing_idx] = new_response
#         else:
#             responses.append(new_response)
#
#         self.process_tracking["responses"] = responses
#
#         # Save or update the process tracking document in MongoDB
#         try:
#             if hasattr(self.main, "answer_collection"):
#                 if "_id" in self.process_tracking:
#                     # Update existing document
#                     self.main.answer_collection.update_one(
#                         {"_id": self.process_tracking["_id"]},
#                         {"$set": {
#                             "responses": self.process_tracking["responses"],
#                             "status": self.process_tracking.get("status", ""),
#                             "complete": self.process_tracking.get("complete", False),
#                             "end_time": self.process_tracking.get("end_time", None)
#                         }}
#                     )
#                 else:
#                     # Insert new document and store the inserted ID
#                     result = self.main.answer_collection.insert_one(self.process_tracking)
#                     self.process_tracking["_id"] = result.inserted_id
#         except Exception as e:
#             print(f"Error saving to DB: {e}")
#
#         self.current_index += 1
#
#         if self.current_index < len(steps):
#             self.update_view()
#         else:
#             # Finalize process
#             self.process_tracking["status"] = "Completed"
#             self.process_tracking["end_time"] = datetime.now()
#             self.process_tracking["complete"] = True
#
#             # Save final state to DB again
#             try:
#                 if hasattr(self.main, "answer_collection") and "_id" in self.process_tracking:
#                     self.main.answer_collection.update_one(
#                         {"_id": self.process_tracking["_id"]},
#                         {"$set": {
#                             "status": self.process_tracking["status"],
#                             "end_time": self.process_tracking["end_time"],
#                             "complete": True,
#                             "responses": self.process_tracking["responses"]
#                         }}
#                     )
#             except Exception as e:
#                 print(f"Error saving final state to DB: {e}")
#
#             try:
#                 if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
#                     self.main.stacked.setCurrentWidget(self.main.grid_widget)
#             except Exception as e:
#                 print(f"Error switching to grid widget: {e}")
#         self.main.change_to_todo_data()
#
#         self.main.populate_load_table()
#     def go_back(self):
#         """Move back one step if possible."""
#         if self.current_index > 0:
#             self.current_index -= 1
#             self.update_view()
#
#     def cancel_process(self):
#         """Cancel the process and record status."""
#         if self.process_tracking is not None:
#             self.process_tracking["status"] = "Cancelled"
#             self.process_tracking["end_time"] = datetime.now()
#
#             try:
#                 if hasattr(self.main, "answer_collection"):
#                     if "_id" in self.process_tracking:
#                         update_data = self.process_tracking.copy()
#                         update_data.pop("_id")
#                         self.main.answer_collection.update_one(
#                             {"_id": self.process_tracking["_id"]},
#                             {"$set": update_data}
#                         )
#                     else:
#                         result = self.main.answer_collection.insert_one(self.process_tracking)
#                         self.process_tracking["_id"] = result.inserted_id
#             except Exception as e:
#                 print(f"Error saving cancellation data: {e}")
#
#         self.process_id = None
#         self.process_tracking = None
#
#         try:
#             if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
#                 self.main.stacked.setCurrentWidget(self.main.grid_widget)
#         except Exception as e:
#             print(f"Error switching UI on cancel: {e}")
#
#
#     def start_process(self, process_data):
#         """Initialize a new process with the provided process_data dict."""
#         if not isinstance(process_data, dict):
#             print("start_process: Invalid input.")
#             return
#
#         self.process_data = process_data
#         self.current_index = 0
#         self.process_tracking = {
#             "start_time": datetime.now(),
#             "title": process_data.get("title", "Untitled"),
#             "process_type_id" : process_data.get("process_id", "unknown key"),
#             "responses": [],
#             "complete": False
#         }
#
#         preset_todo = process_data.get("todo_data")
#         if preset_todo and hasattr(self.main, "todowidget"):
#             try:
#                 self.main.todowidget.load_tasks_from_dict(preset_todo)
#                 print("Preset todo data loaded successfully.")
#             except Exception as e:
#                 print(f"Error loading preset todo data: {e}")
#
#         self.update_view()
#
#     def load_process(self,process_tracking):
#         process_loaded_type_id = process_tracking.get("process_type_id","unknown")
#
#
#         self.process_data = self.main.process_data[process_loaded_type_id]
#         self.process_tracking = process_tracking
#         self.current_index = len(process_tracking.get("responses", []))  # e.g. resume from last response
#
#         self.update_view()

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QStackedWidget,
    QHBoxLayout, QTextBrowser
)
from PyQt5.QtCore import Qt

class RunProcessWidget(QWidget):
    def __init__(self, main,parent=None):
        super().__init__(parent)

        self.process = None
        self.current_index = 0
        self.main = main
        # Widgets for different task types; instantiate here or inject
        self.question_widget = QuestionStepWidget()
        self.check_widget = CheckStepWidget()
        self.subcheck_widget = ChecklistManagerWidget()
        self.multicheck_widget = ChecklistManagerWidget()

        # Map type string to widget instance
        self.widgets_by_type = {
            "question": self.question_widget,
            "check": self.check_widget,
            "subcheck": self.subcheck_widget,
            "multicheck": self.multicheck_widget,
        }

        content_layout = QHBoxLayout(self)

        # Layout setup for the main process UI
        main_layout = QVBoxLayout()





        # Label showing current step info
        self.step_label = QLabel("No process loaded")
        self.step_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.step_label)

        # Container to hold task widgets (switch between them)
        self.step_container = QStackedWidget()
        for widget in self.widgets_by_type.values():
            self.step_container.addWidget(widget)
        main_layout.addWidget(self.step_container)

        # Hint / info browser below task widget
        self.hints_browser = QTextBrowser()
        self.hints_browser.setFixedHeight(100)
        main_layout.addWidget(self.hints_browser)

        # Navigation buttons
        nav_layout = QHBoxLayout()
        self.back_button = QPushButton("Back")
        self.back_button.clicked.connect(self.go_back)
        nav_layout.addWidget(self.back_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.on_next_clicked)
        nav_layout.addWidget(self.next_button)

        main_layout.addLayout(nav_layout)
        # Add main layout first (left side, takes more space)
        content_layout.addLayout(main_layout, stretch=4)

        # Add Todo widget last (right side, smaller space)
        self.running_todo_widget = TodoApp()
        content_layout.addWidget(self.running_todo_widget, stretch=1)

        # Final setup
        self.update_navigation_buttons()
        self.running_todo_widget.todo_changed.connect(self.on_todo_changed)

    def start_process(self, process):
        print(f"start_process called with: {process}")
        if process is None or not hasattr(process, "tasks") or not process.tasks:
            print("Invalid or empty process provided.")
            return
        self.process = process
        self.current_index = 0
        print(f"Process tasks count: {len(process.tasks)}")

        # Load todos into the todo widget if available
        todos = getattr(process, "todos", [])
        print(todos)# adjust if your attribute name is different
        self.running_todo_widget.set_todos(todos)
        print(111,222)
        try:
            self.process.save(self.main.answer_collection)
        except Exception as err:
            print(err)
        print(111,222)

        self.update_view()

    def load_process(self, process):
        print(f"load_process called with: {process}")
        if not isinstance(process, Process):
            print("Invalid process object.")
            return

        self.process = process

        # Set current_index to the first unanswered task
        self.current_index = 0
        for i, task in enumerate(self.process.tasks):
            if not task.answer:  # adjust this if answer can be falsy but valid
                self.current_index = i
                break
        else:
            # All tasks answered; go to last one
            self.current_index = len(self.process.tasks) - 1

        # Load and restore todos
        todos_data = getattr(process, "todos", [])
        restored_todos = []
        for todo_dict in todos_data:
            if isinstance(todo_dict, dict):
                todo = Todo.from_dict(todo_dict)
                restored_todos.append(todo)
            elif isinstance(todo_dict, Todo):
                restored_todos.append(todo_dict)
            else:
                print("Unrecognized todo format:", todo_dict)

        self.running_todo_widget.set_todos(restored_todos)

        # Show the process in the UI
        self.update_view()

    def update_view(self):
        print("update_view called")
        if not self.process or not hasattr(self.process, "tasks"):
            print("No process or tasks available.")
            self.step_label.setText("No process or tasks available.")
            return

        if not (0 <= self.current_index < len(self.process.tasks)):
            print(f"Current index {self.current_index} out of range.")
            self.step_label.setText("Invalid step index.")
            return

        task = self.process.tasks[self.current_index]
        print(f"Current task: {task}")

        task_type = getattr(task, "type", None)
        task_text = getattr(task, "text", "No text")

        print(f"Task type: {task_type}")
        print(f"Task text: {task_text}")

        widget = self.widgets_by_type.get(task_type)
        if not widget:
            print(f"No widget found for task type: {task_type}")
            self.step_label.setText(f"Unsupported task type: {task_type}")
            return

        self.step_label.setText(f"Step {self.current_index + 1} of {len(self.process.tasks)}")

        try:
            if task_type == "question" and hasattr(widget, "set_question_text"):
                widget.set_question_text(task_text)
            elif task_type == "check" and hasattr(widget, "set_check_text"):
                widget.set_check_text(task_text)
            elif task_type == "subcheck":
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(task_text)
                if hasattr(widget, "reset"):
                    widget.reset()
            elif task_type == "multicheck":
                items = getattr(task, "items", [])
                if not isinstance(items, list):
                    items = []
                if hasattr(widget, "load_checks"):
                    widget.load_checks(items)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(task_text)
            else:
                print(f"Unknown task type: {task_type}")
        except Exception as e:
            print(f"Error updating widget: {e}")
            self.step_label.setText(f"Error updating widget: {e}")
            return

        self.step_container.setCurrentWidget(widget)

        hints = getattr(task, "hints", None)
        html = "<i>No hints for this step.</i>"
        if isinstance(hints, list) and hints:
            html = "<b>Hints:</b><br>" + "<br>".join(f"&bull; {line}" for line in hints)
        elif isinstance(hints, str) and hints.strip():
            html = f"<b>Hint:</b> {hints.strip()}"

        self.hints_browser.setHtml(html)
        self.update_navigation_buttons()

        is_last_step = self.current_index == len(self.process.tasks) - 1
        self.next_button.setText("Finish" if is_last_step else "Next")
        self.next_button.setEnabled(True)

    def update_navigation_buttons(self):
        if not self.process or not hasattr(self.process, "tasks"):
            self.back_button.setEnabled(False)
            self.next_button.setEnabled(False)
            return
        self.back_button.setEnabled(self.current_index > 0)
        self.next_button.setEnabled(self.current_index < len(self.process.tasks) - 1)

    def go_back(self):
        if self.current_index > 0:
            self.current_index -= 1
            self.update_view()

    def on_next_clicked(self):
        current_task = self.process.tasks[self.current_index]
        current_widget = self.widgets_by_type.get(current_task.type)
        if current_widget is None:
            print("No widget for current task type")
            return

        if not current_widget.is_valid():
            QMessageBox.warning(self, "Incomplete Step", "Please complete the current step before proceeding.")
            return

        # Save current input data into the process task
        if hasattr(current_widget, "get_data"):
            data = current_widget.get_data()
            current_task.answer = data  # save the answer or data in the process task
        self.process.save(self.main.answer_collection)
        if self.current_index < len(self.process.tasks) - 1:
            self.current_index += 1
            self.update_view()
        else:

            self.finish_process()

    def return_to_main(self):
        # Reset internal data
        self.process = None
        self.current_index = 0
        self.tasks = []

        print("aa")
        self.main.stacked.setCurrentWidget(self.main.grid_widget)


    def finish_process(self):
        try:
            if not self.running_todo_widget.is_valid():
                QMessageBox.warning(self, "Incomplete Todos", "Please complete all todos before finishing the process.")
                return

            # Remove from pending and add to finished
            if self.process in self.main.processes_pending:
                self.main.processes_pending.remove(self.process)

            self.main.finished_processes.append(self.process)

            # You can collect data from all tasks here if needed
            print("Process finished.")
            self.process.end()
            self.process.save(self.main.answer_collection)
            self.return_to_main()

            # Do your finishing logic, e.g., save, mark status, close widget...
        except Exception as err:
            print(000,err)

    def on_todo_changed(self):
        try:
            print("test")
            if not self.process:
                return

            # Get updated todos from the TodoApp
            updated_todos = self.running_todo_widget.get_todos()

            # Assign them to the current process
            self.process.todos = updated_todos

            # Save process
            self.process.save(self.main.answer_collection)
        except Exception as err:
            print(98,err)

class MainGridWidget(QWidget):
    def __init__(self, main):
        super().__init__()
        self.layout = QGridLayout(self)
        self.main = main
        self.buttons = {}  # Save buttons by position (i, j)
        self.populate_grid()

    def populate_grid(self):
        print(self.main.process_data)
        for i in range(10):
            for j in range(5):
                button_id = None
                color = None
                button = RightClickableButton(self.main, (i, j), load_color=color, load_id=button_id)
                for template in self.main.templates:
                    if template.button_position == (i, j):
                        print(11235456)

                        button.button_template = template

                        button.color = template.button_color
                        button.update_button()
                        break

                self.layout.addWidget(button, i, j)
                self.buttons[(i, j)] = button




class AddSubDialog(QDialog):
    def __init__(self, parent=None, edit=None):
        super().__init__(parent)
        self.setWindowTitle("Add New Sub")
        self.setModal(True)
        self.setMinimumWidth(300)
        self.edit = edit  # Optional dict for editing an existing step

        layout = QVBoxLayout(self)

        # --- Type selection combo box ---
        layout.addWidget(QLabel("Sub Type:"))
        self.type_combo = QComboBox()
        self.type_combo.addItems(["question", "check", "subcheck", "multicheck"])
        layout.addWidget(self.type_combo)

        # --- Dynamic container for input fields ---
        self.input_container = QVBoxLayout()
        layout.addLayout(self.input_container)

        # --- OK / Cancel Buttons ---
        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)

        # Signal connections
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.ok_button.setEnabled(False)  # Disabled until input is valid

        if edit:
            type_str = edit.get("type", "")
            index = self.type_combo.findText(type_str, Qt.MatchFixedString)
            self.type_combo.setCurrentIndex(index if index >= 0 else 0)
        else:
            self.type_combo.setCurrentIndex(0)

        self.type_combo.currentIndexChanged.connect(self.rebuild_entry)

        self.rebuild_entry()

        if edit:
            QTimer.singleShot(0, self.prefill_edit)

    def prefill_edit(self):
        subtype = self.type_combo.currentText()
        text = self.edit.get("text", "")

        if subtype == "multicheck":
            title = self.edit.get("text", "")
            items = self.edit.get("items", [])
            if self.text_title:
                self.text_title.setText(title)
            if self.text_widget and isinstance(items, list):
                self.text_widget.setPlainText("\n".join(items))
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit) and isinstance(text, str):
                self.text_widget.setText(text)

        # --- Prefill hint field if available ---
        hints = self.edit.get("hints", [])
        if isinstance(hints, list) and self.hint_widget:
            self.hint_widget.setPlainText("\n".join(hints))

    def validate_input(self):
        subtype = self.type_combo.currentText()
        valid = False

        if subtype == "multicheck":
            if self.text_title and self.text_widget:
                valid = bool(self.text_title.text().strip() and self.text_widget.toPlainText().strip())
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit):
                valid = bool(self.text_widget.text().strip())

        self.ok_button.setEnabled(valid)

    def get_data(self):
        subtype = self.type_combo.currentText()

        # Parse hints from QTextEdit into list of trimmed non-empty lines
        hints = []
        if self.hint_widget:
            hints = [
                line.strip() for line in self.hint_widget.toPlainText().splitlines() if line.strip()
            ]

        if subtype == "multicheck":
            if not self.text_title or not self.text_widget:
                return {"type": subtype, "text": "", "items": [], "hints": hints}
            title = self.text_title.text().strip()
            items = [
                line.strip() for line in self.text_widget.toPlainText().splitlines() if line.strip()
            ]
            return {
                "type": subtype,
                "text": title,
                "items": items,
                "hints": hints
            }
        else:
            text = self.text_widget.text().strip() if self.text_widget else ""
            return {
                "type": subtype,
                "text": text,
                "hints": hints
            }

    def rebuild_entry(self):
        # Clear all widgets from the input container
        for i in reversed(range(self.input_container.count())):
            widget = self.input_container.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # Reset references
        self.text_widget = None
        self.text_title = None
        self.hint_widget = None

        subtype = self.type_combo.currentText()

        if subtype == "multicheck":
            self.input_container.addWidget(QLabel("Checklist Title:"))
            self.text_title = QLineEdit()
            self.text_title.setPlaceholderText("Enter checklist title...")
            self.input_container.addWidget(self.text_title)

            self.input_container.addWidget(QLabel("Checklist Items:"))
            self.text_widget = QTextEdit()
            self.text_widget.setPlaceholderText("Enter multiple options, one per line...")
            self.input_container.addWidget(self.text_widget)

            self.text_title.textChanged.connect(self.validate_input)
            self.text_widget.textChanged.connect(self.validate_input)
        else:
            self.input_container.addWidget(QLabel("Text:"))
            self.text_widget = QLineEdit()
            self.text_widget.setPlaceholderText("Enter sub-process text...")
            self.input_container.addWidget(self.text_widget)
            self.text_widget.textChanged.connect(self.validate_input)

        # --- Add hint input field for all types ---
        self.input_container.addWidget(QLabel("Hints (one per line):"))
        self.hint_widget = QTextEdit()
        self.hint_widget.setPlaceholderText("Enter optional hints for this step...")
        self.input_container.addWidget(self.hint_widget)

        self.validate_input()
class EditProcessesWidget(QWidget):
    def __init__(self, main):
        super().__init__()



        self.main = main

        # Main layout
        main_layout = QVBoxLayout(self)

        # Header label styled as a header
        header = QLabel("Edit Processes View")
        header.setFont(QFont("Arial", 16, QFont.Bold))
        header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(header)

        # Horizontal layout: list on left, buttons on right
        content_layout = QHBoxLayout()

        # Left side: process list (single-select)
        self.process_list = QListWidget()
        self.process_list.setSelectionMode(QListWidget.SingleSelection)
        for key in self.main.process_data.keys():
            list_item = QListWidgetItem(self.main.process_data[key]["title"])  # show only the title
            list_item.setData(Qt.UserRole, key)  # store full dict
            self.process_list.addItem(list_item)
        content_layout.addWidget(self.process_list)

        # Right side: buttons
        button_layout = QVBoxLayout()

        self.run_button = QPushButton("Run")
        self.run_button.clicked.connect(self.run_process)
        button_layout.addWidget(self.run_button)

        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.create_new_template)
        button_layout.addWidget(self.add_button)

        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self.edit_process)
        button_layout.addWidget(self.edit_button)

        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_process)
        button_layout.addWidget(self.delete_button)

        content_layout.addLayout(button_layout)

        # Add content to main layout
        main_layout.addLayout(content_layout)

        self.update_edit_templates_list()


    def update_edit_templates_list(self):
        self.process_list.clear()  # clear the list before repopulating

        for template in self.main.templates:
            title = template.title or "Untitled Template"
            item = QListWidgetItem(title)  # Display only title
            item.setData(Qt.UserRole, template)  # Store the full object
            self.process_list.addItem(item)

    # === Button Handlers ===
    def run_process(self):
        selected_item = self.process_list.currentItem()
        if selected_item is None:
            QMessageBox.warning(self, "No Selection", "Please select a process to run.")
            return

        # Retrieve your actual ProcessTemplate instance:
        template = selected_item.data(Qt.UserRole)

        if not isinstance(template, ProcessTemplate):
            QMessageBox.warning(self, "Invalid Data", "Selected item is not a valid process template.")
            return

        self.main.run_process_from_template(template)

    def create_new_template(self):
        self.main.stacked.setCurrentWidget(self.main.new_widget)
        self.main.new_widget.create_empty_template()
        self.main.new_widget.new_mode = True
        self.main.new_widget.todo_template_widget.clear_tasks()


    def add_process(self):
        try:
            self.main.stacked.setCurrentWidget(self.main.new_widget)
            self.main.new_widget.process_id = str(uuid.uuid4())
            self.main.process_data[self.main.new_widget.process_id] = {"process_id":self.main.new_widget.process_id,"title":"new process","sub_process_data":[]}
            print(self.main.process_data)
        except Exception as err:
            print(888, str(err))

    def edit_process(self):

        selected_item = self.process_list.currentItem()
        if not selected_item:
            print("No process selected for editing.")
            return

        selected_template = selected_item.data(Qt.UserRole)
        self.main.new_widget.pending_template = selected_template
        self.main.new_widget.new_mode = False
        self.main.stacked.setCurrentWidget(self.main.new_widget)

        # Set title
        self.main.new_widget.title_input.setText(selected_template.title or "")

        # Clear and re-populate the subs list
        self.main.new_widget.subs_list.clear()
        self.main.new_widget.refresh_subs_list()

    def edit_process(self):
        selected_item = self.process_list.currentItem()
        if not selected_item:
            print("No process selected for editing.")
            return

        selected_template = selected_item.data(Qt.UserRole)
        self.main.new_widget.new_mode = False
        self.main.stacked.setCurrentWidget(self.main.new_widget)

        # Use load_template to set all data in new_widget
        self.main.new_widget.load_template(selected_template)

        print(selected_template)


    def delete_process(self):
        print("Delete")

class NewProcessWidget(QWidget):
    def __init__(self, main):
        super().__init__()

        self.new_mode = None
        self.process_id = None
        self.pending_template = None
        self.main = main

        # Create main horizontal layout (side by side)
        global_view_layout = QHBoxLayout(self)

        # Left side: TodoApp widget
        self.todo_template_widget = TodoApp()
        global_view_layout.addWidget(self.todo_template_widget)

        # Right side: everything else
        right_side_layout = QVBoxLayout()

        # Header
        self.header = QLabel("New Process View")
        self.header.setFont(QFont("Arial", 16, QFont.Bold))
        self.header.setAlignment(Qt.AlignCenter)
        right_side_layout.addWidget(self.header)

        # Title input + confirm button in a row
        title_row = QHBoxLayout()
        title_label = QLabel("Title:")
        self.title_input = QLineEdit()
        confirm_title_button = QPushButton("Confirm Title")
        confirm_title_button.clicked.connect(self.confirm_title)
        title_row.addWidget(title_label)
        title_row.addWidget(self.title_input)
        title_row.addWidget(confirm_title_button)
        right_side_layout.addLayout(title_row)

        # Sub-processes and buttons in horizontal layout
        content_layout = QHBoxLayout()

        # Sub-process list
        subs_layout = QVBoxLayout()
        subs_label = QLabel("Sub-Processes:")
        subs_layout.addWidget(subs_label)
        self.subs_list = QListWidget()
        self.subs_list.setSelectionMode(QListWidget.SingleSelection)
        subs_layout.addWidget(self.subs_list)
        content_layout.addLayout(subs_layout)

        # Buttons for sub-processes
        button_layout = QVBoxLayout()
        buttons = [
            ("Add", self.add_new_task),
            ("Edit", self.edit_clicked),
            ("Delete", self.delete_clicked),
            ("Up", self.up_clicked),
            ("Down", self.down_clicked),
        ]
        for text, handler in buttons:
            btn = QPushButton(text)
            btn.clicked.connect(handler)
            button_layout.addWidget(btn)
        button_layout.addStretch()
        content_layout.addLayout(button_layout)

        right_side_layout.addLayout(content_layout)

        # Bottom buttons
        bottom_buttons_layout = QHBoxLayout()
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.cancel_clicked)
        confirm_button = QPushButton("Confirm")
        confirm_button.clicked.connect(self.confirm_clicked)
        bottom_buttons_layout.addWidget(cancel_button)
        bottom_buttons_layout.addWidget(confirm_button)
        right_side_layout.addLayout(bottom_buttons_layout)

        global_view_layout.addLayout(right_side_layout)

        self.setLayout(global_view_layout)


    def confirm_title(self):
        title = self.title_input.text()
        self.header.setText(title if title else "New Process View")
        self.pending_template.title = title

    def create_empty_template(self):
        self.pending_template =  ProcessTemplate()


    def add_new_task(self):
        dialog = AddSubDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()
            task = Task.from_dict(data)
            self.pending_template.tasks.append(task)
            print(self.pending_template.to_dict())
            print(665544,task)
            self.refresh_subs_list()


    def edit_clicked(self):
        selected_item = self.subs_list.currentItem()
        selected_index = self.subs_list.currentRow()
        if not selected_item or selected_index < 0:
            return  # No selection

        # Retrieve full Task object stored in the item
        task = selected_item.data(Qt.UserRole)

        # Pass the task data (as dict) to your dialog for editing
        dialog = AddSubDialog(self, edit=task.to_dict())
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()

            # Update the Task instance in your pending_template.tasks list
            updated_task = Task.from_dict(data)
            self.pending_template.tasks[selected_index] = updated_task

            # Optionally save or sync your main data store here
            # e.g. self.main.save_process_to_mdb(self.process_id)

            # Refresh the list widget display
            self.refresh_subs_list()

    def delete_clicked(self):
        selected_item = self.subs_list.currentItem()
        selected_index = self.subs_list.currentRow()

        if selected_item is None or selected_index < 0:
            return  # No selection, nothing to delete

        # Show confirmation dialog
        reply = QMessageBox.question(
            self,
            "Confirm Delete",
            f"Are you sure you want to delete the task '{selected_item.text()}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            # Remove from your data list
            del self.pending_template.tasks[selected_index]

            # Refresh the list widget
            self.refresh_subs_list()

    def up_clicked(self):
        index = self.subs_list.currentRow()
        tasks = self.pending_template.tasks

        if index <= 0 or index >= len(tasks):
            return  # Can't move first item up or invalid index

        # Swap tasks
        tasks[index - 1], tasks[index] = tasks[index], tasks[index - 1]

        # Save changes - replace this with your actual save logic
        #self.save_process()

        self.refresh_subs_list()
        self.subs_list.setCurrentRow(index - 1)

    def down_clicked(self):
        index = self.subs_list.currentRow()
        tasks = self.pending_template.tasks

        if index < 0 or index >= len(tasks) - 1:
            return  # Can't move last item down or invalid index

        # Swap tasks
        tasks[index + 1], tasks[index] = tasks[index], tasks[index + 1]

        # Save changes - replace this with your actual save logic
        #self.save_process()

        self.refresh_subs_list()
        self.subs_list.setCurrentRow(index + 1)



    def refresh_subs_list(self):
        self.subs_list.clear()
        for task in self.pending_template.tasks:
            label = f"{task.type}:  {task.text}" or "Untitled Task"
            item = QListWidgetItem(label)
            item.setData(Qt.UserRole, task)  # Store full Task object
            self.subs_list.addItem(item)
            self.subs_list.clearSelection()

    def load_template(self, template):
        self.pending_template = template

        # Update UI fields
        self.title_input.setText(self.pending_template.title or "")
        self.header.setText(self.pending_template.title or "New Process View")

        # Refresh the sub-processes list
        self.refresh_subs_list()

        # Load the todos into the widget
        self.todo_template_widget.set_todos(self.pending_template.todos)

    def cancel_clicked(self):
        # Switch back to edit processes widget
        self.main.stacked.setCurrentWidget(self.main.edit_widget)

        # Reset UI in NewProcessWidget
        self.main.new_widget.title_input.clear()
        self.main.new_widget.header.setText("New Process View")
        self.main.new_widget.subs_list.clear()

    def save_new_process(self):
        try:
            print(4444,self.pending_template.save_to_mdb(self.main.process_collection))
        except Exception as err:
            print(999,err)

    def confirm_clicked(self):
        try:

            self.update_todos_from_widget()  # Sync todos before saving

            if self.new_mode:
                # Save new process
                self.save_new_process()
                self.main.templates.append(self.pending_template)  # Add new template to the list

            else:
                # Update existing template in the list
                for i, template in enumerate(self.main.templates):
                    if template.template_id == self.pending_template.template_id:
                        self.main.templates[i] = self.pending_template  # Overwrite with updated version
                        break

                # Save updated template to MongoDB
                self.pending_template.save_to_mdb(self.main.process_collection)  # Ensure save_to_mdb handles upsert

            # Switch back to edit view and refresh the list
            self.main.stacked.setCurrentWidget(self.main.edit_widget)
            self.main.edit_widget.update_edit_templates_list()

        except Exception as err:
            print("Error in confirm_clicked:", err)

    def update_todos_from_widget(self):
        self.pending_template.todos = self.todo_template_widget.get_todos()

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Process Manager")
        self.resize(800, 600)

        self.debug_browser = QTextBrowser()
        self.debug_browser.setMinimumHeight(100)
        self.debug_browser.setStyleSheet("font-family: monospace; background-color: #f0f0f0;")
        self.debug_timer = QTimer(self)
        self.debug_timer.timeout.connect(self.update_debug_info)
        self.debug_timer.start(2000)

        self.processes_pending = []
        self.templates = []

        self.uri = uri

        self.todowidget = TodoApp()

        main_layout = QVBoxLayout(self)

        # init mongo connection
        client = MongoClient(self.uri)
        db = client["process_tool"]
        self.answer_collection = db["processes_completed"]
        self.answer_collection.insert_one({"title":"connection","time":datetime.now()})
        self.process_collection = db["processes_new"]

        self.process_data = {
            doc["idkey"]: doc
            for doc in self.process_collection.find()
            if "idkey" in doc  # optional safety check
        }

        template_dicts = list(self.process_collection.find())  # a list of dicts from MongoDB
        self.templates = [ProcessTemplate.from_dict(d) for d in template_dicts]

        # Top buttons (only 3 now)
        button_layout = QHBoxLayout()
        self.run_button = QPushButton("Run")
        self.grid_button = QPushButton("Main Grid")
        self.edit_button = QPushButton("Edit Processes")

        for btn in (self.grid_button, self.edit_button):
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # Stacked widget setup
        self.stacked = QStackedWidget()
        self.run_widget = RunProcessWidget(self)
        self.grid_widget = MainGridWidget(self)
        self.edit_widget = EditProcessesWidget(self)
        self.new_widget = NewProcessWidget(self)  # Still available if needed


        # Horizontal layout for widgets side-by-side
        content_layout = QHBoxLayout()
        content_layout.addWidget(self.todowidget)
        content_layout.addWidget(self.stacked)

        main_layout.addLayout(content_layout)

        self.stacked.addWidget(self.run_widget)
        self.stacked.addWidget(self.grid_widget)
        self.stacked.addWidget(self.edit_widget)
        self.stacked.addWidget(self.new_widget)

        # Connect buttons to view changes
        self.run_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.run_widget))
        self.grid_button.clicked.connect(self.return_to_main)
        self.edit_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.edit_widget))

        # Default view
        self.stacked.setCurrentWidget(self.grid_widget)

        self.save_and_load_widget = QTableWidget()

        main_layout.addWidget(self.save_and_load_widget)

        self.stacked.currentChanged.connect(self.populate_load_table)

        # Enable custom context menu
        self.save_and_load_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.save_and_load_widget.customContextMenuRequested.connect(self.open_menu)
        self.save_and_load_widget.cellDoubleClicked.connect(self.load_on_double_click)
        self.stacked.currentChanged.connect(self.unload_todo_widget)

        self.populate_load_table()
        self.unload_todo_widget(1)


        main_layout.addWidget(self.debug_browser)

    def change_to_todo_data(self):
        try:
            if hasattr(self, "todowidget") and self.todowidget and hasattr(self, "run_widget"):
                if hasattr(self.run_widget, "process_tracking") and self.run_widget.process_tracking is not None:
                    self.run_widget.process_tracking["todo_data"] = self.todowidget.get_tasks_as_dict()
        except Exception as err:
            print("Error saving todo data:", err)

    def update_debug_info(self):
        try:
            process_id = getattr(self.run_widget, "process_id", None)
            process_data = getattr(self.run_widget, "process_data", None)
            current_index = getattr(self.run_widget, "current_index", None)

            debug_text = f"""
            <b>Process ID:</b> {process_id}<br>
            <b>Current Index:</b> {current_index}<br>
            <b>Process Data:</b><br><pre>{pprint.pformat(process_data)}</pre>
            """.strip()

            self.debug_browser.setHtml(debug_text)
        except Exception as e:
            self.debug_browser.setPlainText(f"Debug update error: {e}")

    def return_to_main(self):
        self.stacked.setCurrentWidget(self.grid_widget)
        try:
            if hasattr(self, "answer_collection"):
                self.answer_collection.insert_one(self.run_widget.process_tracking)
        except Exception as e:
            print(f"Error saving cancellation data: {e}")


    def save_process_to_mdb(self, id):
        self.process_collection.update_one(
            {"idkey": id},
            {"$set": self.process_data[id]},
            upsert=True
        )

    def load_on_double_click(self, row, column):
        item  = self.save_and_load_widget.item(row,0)
        mongo_id = ObjectId(item.data(Qt.UserRole))
        temp_status = self.answer_collection.find_one({'_id': mongo_id})
        self.run_widget.load_process(temp_status)
        self.stacked.setCurrentWidget(self.run_widget)

        print(temp_status)
        #self.run_widget.start_process(self.process_data[id])


    def open_menu(self, position: QPoint):
        index = self.save_and_load_widget.indexAt(position)
        if not index.isValid():
            return

        row = index.row()
        process_name = self.save_and_load_widget.item(row, 0).text()  # Adjust if your "process" column is elsewhere

        menu = QMenu()
        action_kill = QAction(f"Kill process '{process_name}'", self)
        action_details = QAction("View Details", self)

        action_kill.triggered.connect(lambda: self.kill_process(row))
        action_details.triggered.connect(lambda: self.view_details(row))

        menu.addAction(action_kill)
        menu.addAction(action_details)
        menu.exec_(self.save_and_load_widget.viewport().mapToGlobal(position))

    def kill_process(self, row):
        try:
            process_name = self.save_and_load_widget.item(row, 0).text()  # Adjust column index if needed
            pid = self.save_and_load_widget.item(row, 1).text()  # Assuming PID is in column 1
            item = self.save_and_load_widget.item(row, 0)  # or any item in the row
            mongo_id =  ObjectId(item.data(Qt.UserRole))
            print(mongo_id)
            reply = QMessageBox.question(
                self,
                "Confirm Kill",
                f"Are you sure you want to kill process '{process_name}' (PID {pid})?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                self.run_widget.cancel_process()
                self.answer_collection.update_one(
                    {"_id": mongo_id},  # or another unique filter
                    {
                        "$set": {
                            "complete": True,
                            "status": "deleted"
                        }
                    }
                )
                self.populate_load_table()

                #return to main widget

            else:
                print("Kill cancelled.")
        except Exception as err:
            print(err)

    def view_details(self, row):
        print(f"View details for row {row}")

    def run_process(self,id):
        #print(22,self.process_data[id])
        self.stacked.setCurrentWidget(self.run_widget)
        self.run_widget.start_process(self.process_data[id])

    def unload_todo_widget(self,index):
        current_widget = self.stacked.widget(index)

        if current_widget in [self.grid_widget,self.edit_widget]:
            self.todowidget.hide()
        else:
            self.todowidget.show()
    def populate_load_table(self):
        # Clear existing contents and reset row/column counts
        self.save_and_load_widget.clearContents()
        self.save_and_load_widget.setRowCount(0)
        self.save_and_load_widget.setColumnCount(0)

        query = {
            "complete": False,
            "status": {"$ne": "deleted"}  # Exclude deleted
        }
        results = list(self.answer_collection.find(query))
        print(5555, results)
        if not results:
            return

        # Set row and column counts based on results
        self.save_and_load_widget.setRowCount(len(results))
        # Use keys from first document as column headers (exclude _id if desired)
        keys = list(results[0].keys())
        self.save_and_load_widget.setColumnCount(len(keys))
        self.save_and_load_widget.setHorizontalHeaderLabels(keys)

        # Populate table
        for row, entry in enumerate(results):
            for col, key in enumerate(keys):
                value = entry.get(key, "")
                text = str(value)

                # Create a preview if text is long
                preview = text if len(text) <= 40 else text[:37] + "..."

                item = QTableWidgetItem(preview)
                # Make cell non-editable
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # Tooltip shows full text on hover
                item.setToolTip(text)

                self.save_and_load_widget.setItem(row, col, item)

            # Store the MongoDB _id (as string) in the first column's UserRole data for access later
            id_item = self.save_and_load_widget.item(row, 0)
            if id_item:
                id_item.setData(Qt.UserRole, str(entry.get("_id", "")))

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Process Manager")
        self.resize(800, 600)

        self.debug_browser = QTextBrowser()
        self.debug_browser.setMinimumHeight(100)
        self.debug_browser.setStyleSheet("font-family: monospace; background-color: #f0f0f0;")
        self.debug_timer = QTimer(self)
        self.debug_timer.timeout.connect(self.update_debug_info)
        self.debug_timer.start(2000)

        self.processes_pending = []
        self.finished_processes = []
        self.templates = []

        self.uri = uri

        main_layout = QVBoxLayout(self)

        # init mongo connection
        client = MongoClient(self.uri)
        db = client["process_tool"]
        self.answer_collection = db["processes_completed_new"]
        self.answer_collection.insert_one({"title":"connection","time":datetime.now()})
        self.process_collection = db["processes_new"]

        self.process_data = {
            doc["idkey"]: doc
            for doc in self.process_collection.find()
            if "idkey" in doc  # optional safety check
        }

        # Ctrl+S triggers a save function on a specific widget
        shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        shortcut.activated.connect(self.fast_return)

        shortcut = QShortcut(QKeySequence("Ctrl+Shift+a"), self)
        shortcut.activated.connect(self.enter_new_todo)

        shortcut = QShortcut(QKeySequence("Ctrl+Shift+Return"), self)
        shortcut.activated.connect(self.confirm_new_todo)

        shortcut = QShortcut(QKeySequence("Ctrl+Shift+s"), self)
        shortcut.activated.connect(self.select_next_unchecked)

        ctrl_shift_space_shortcut = QShortcut(QKeySequence(Qt.CTRL + Qt.SHIFT + Qt.Key_Space), self)
        ctrl_shift_space_shortcut.activated.connect(self.check_selection)

        template_dicts = list(self.process_collection.find())  # a list of dicts from MongoDB
        self.templates = [ProcessTemplate.from_dict(d) for d in template_dicts]
        query = {
            "status": {"$in": ["created", "running", "paused"]}  # or whatever statuses mean pending
        }
        cursor = self.answer_collection.find(query)
        self.processes_pending = [Process.from_dict(doc) for doc in cursor]
        print(88,self.processes_pending)

        # Top buttons (only 3 now)
        button_layout = QHBoxLayout()
        self.run_button = QPushButton("Run")
        self.grid_button = QPushButton("Main Grid")
        self.edit_button = QPushButton("Edit Processes")

        for btn in (self.grid_button, self.edit_button):
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # Stacked widget setup
        self.stacked = QStackedWidget()
        self.run_widget = RunProcessWidget(self)
        self.grid_widget = MainGridWidget(self)
        self.edit_widget = EditProcessesWidget(self)
        self.new_widget = NewProcessWidget(self)  # Still available if needed

        # Only the stacked widget (no todo widget side-by-side)
        main_layout.addWidget(self.stacked)

        self.stacked.addWidget(self.run_widget)
        self.stacked.addWidget(self.grid_widget)
        self.stacked.addWidget(self.edit_widget)
        self.stacked.addWidget(self.new_widget)

        # Connect buttons to view changes
        #self.run_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.run_widget))
        self.run_button.clicked.connect(self.on_run_button_clicked)

        self.grid_button.clicked.connect(self.return_to_main)
        self.edit_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.edit_widget))

        # Default view
        self.stacked.setCurrentWidget(self.grid_widget)

        self.save_and_load_widget = QTableWidget()
        main_layout.addWidget(self.save_and_load_widget)

        self.stacked.currentChanged.connect(self.populate_load_table)

        # Enable custom context menu
        self.save_and_load_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.save_and_load_widget.customContextMenuRequested.connect(self.open_menu)
        self.save_and_load_widget.cellDoubleClicked.connect(self.load_on_double_click)

        self.populate_load_table()

        main_layout.addWidget(self.debug_browser)

    def update_debug_info(self):
        try:
            process_id = getattr(self.run_widget, "process_id", None)
            process_data = getattr(self.run_widget, "process_data", None)
            current_index = getattr(self.run_widget, "current_index", None)

            debug_text = f"""
            <b>Process ID:</b> {process_id}<br>
            <b>Current Index:</b> {current_index}<br>
            <b>Process Data:</b><br><pre>{pprint.pformat(process_data)}</pre>
            """.strip()

            self.debug_browser.setHtml(debug_text)
        except Exception as e:
            self.debug_browser.setPlainText(f"Debug update error: {e}")

    def return_to_main(self):
        self.stacked.setCurrentWidget(self.grid_widget)
        try:
            if hasattr(self, "answer_collection"):
                self.answer_collection.insert_one(self.run_widget.process_tracking)
        except Exception as e:
            print(f"Error saving cancellation data: {e}")

    def save_process_to_mdb(self, id):
        self.process_collection.update_one(
            {"idkey": id},
            {"$set": self.process_data[id]},
            upsert=True
        )

    def load_on_double_click(self, row, column):
        try:

            item = self.save_and_load_widget.item(row, 0)
            process = item.data(Qt.UserRole)

            process_id = process.process_id

            # Find the Process instance by ID from pending_processes
            selected_process = next(
                (p for p in self.processes_pending if p.process_id == process_id), None
            )

            if selected_process:
                self.run_widget.load_process(selected_process)
                self.stacked.setCurrentWidget(self.run_widget)
                print("Loaded process:", selected_process)
            else:
                print("Process with ID", process_id, "not found in pending_processes.")
        except Exception as err:
            print(err)
    def open_menu(self, position: QPoint):
        index = self.save_and_load_widget.indexAt(position)
        if not index.isValid():
            return

        row = index.row()
        process_name = self.save_and_load_widget.item(row, 0).text()  # Adjust if your "process" column is elsewhere

        menu = QMenu()
        action_kill = QAction(f"Kill process '{process_name}'", self)
        action_details = QAction("View Details", self)

        action_kill.triggered.connect(lambda: self.kill_process(row))
        action_details.triggered.connect(lambda: self.view_details(row))

        menu.addAction(action_kill)
        menu.addAction(action_details)
        menu.exec_(self.save_and_load_widget.viewport().mapToGlobal(position))

    def fast_return(self):
        if self.stacked.currentWidget()  == self.run_widget:
            self.run_widget.on_next_clicked()

    def check_selection(self):
        current_widget = self.stacked.currentWidget()
        if current_widget  in [self.run_widget,self.new_widget]:
            if current_widget == self.run_widget:
                print("AAA")
                current_widget.running_todo_widget.check_selected_task()
            elif current_widget == self.new_widget:
                print("AAA")
                current_widget.todo_template_widget.check_selected_task()

    def enter_new_todo(self):
        current_widget = self.stacked.currentWidget()
        if current_widget  in [self.run_widget,self.new_widget]:
            if current_widget == self.run_widget:
                print("AAA")
                current_widget.running_todo_widget.task_input.setFocus()
            elif current_widget == self.new_widget:
                print("AAA")
                current_widget.todo_template_widget.task_input.setFocus()

    def select_next_unchecked(self):
        current_widget = self.stacked.currentWidget()
        if current_widget  in [self.run_widget,self.new_widget]:
            if current_widget == self.run_widget:
                print("BBB")
                selected_task = current_widget.running_todo_widget.select_next_unchecked_task()
                print(444444,selected_task)
                current_widget.running_todo_widget.scroll_to_task(selected_task)
            elif current_widget == self.new_widget:
                print("BBB")
                selected_task = current_widget.todo_template_widget.select_next_unchecked_task()
                current_widget.todo_template_widget.scroll_to_task(selected_task)

    def confirm_new_todo(self):
        current_widget = self.stacked.currentWidget()
        if current_widget  in [self.run_widget,self.new_widget]:
            if current_widget == self.run_widget:
                print("AAA")
                current_widget.running_todo_widget.add_task()
            elif current_widget == self.new_widget:
                print("AAA")
                current_widget.todo_template_widget.add_task()

    def confirm_new_todo(self):
        current_widget = self.stacked.currentWidget()
        if current_widget  in [self.run_widget,self.new_widget]:
            if current_widget == self.run_widget:
                print("AAA")
                current_widget.running_todo_widget.add_task()
            elif current_widget == self.new_widget:
                print("AAA")
                current_widget.todo_template_widget.add_task()

    def kill_process(self, row):
        try:

            item = self.save_and_load_widget.item(row, 0)
            if item is not None:
                process_to_kill = item.data(Qt.UserRole)  # <-- this gets your stored object

            reply = QMessageBox.question(
                self,
                "Confirm Kill",
                f"Are you sure you want to kill process '{process_to_kill.title}' ?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            print(456789,self.answer_collection.find_one(
                    {"process_id": process_to_kill.process_id}))
            doc = self.answer_collection.find_one({"process_id": process_to_kill.process_id})

            print("Before update:", doc["status"])

            print("Querying for process_id:", repr(process_to_kill.process_id))
            doc = self.answer_collection.find_one({"process_id": process_to_kill.process_id})
            print("Found:", doc)

            print("DB:", self.answer_collection.database.name)
            print("Collection:", self.answer_collection.name)

            if reply == QMessageBox.Yes:
                self.answer_collection.update_one(
                    {"process_id": process_to_kill.process_id},  # or another unique filter
                    {
                        "$set": {
                            "status": "deleted"
                        }
                    }
                )

            # Fetch the updated document
            updated_doc = self.answer_collection.find_one({"process_id": process_to_kill.process_id})
            print("After update:", updated_doc["status"])
            self.processes_pending.remove(process_to_kill)
            self.populate_load_table()
            return




            if reply == QMessageBox.Yes:
                self.run_widget.cancel_process()


            else:
                print("Kill cancelled.")
        except Exception as err:
            print(err)

    def view_details(self, row):
        print(f"View details for row {row}")

    def on_run_button_clicked(self):
        print(444)
        try:
            # Example: get selected template from somewhere
            selected_template = self.get_selected_template()
            if selected_template:
                self.run_process_from_template(selected_template)
            else:
                print("No template selected!")
        except Exception as err:
            print(err)


    def run_process(self,id):



        self.stacked.setCurrentWidget(self.run_widget)
        self.run_widget.start_process(self.process_data[id])

    def run_process_from_template(self, template: ProcessTemplate):
        print(444)
        # Create a new Process instance from the template
        new_process = Process.from_template(template)

        self.processes_pending.append(new_process)

        print(555,self.processes_pending)
        # Start the process (sets status to 'running' if applicable)
        try:
            new_process.start()
        except RuntimeError as e:
            print(f"Error starting process: {e}")

        # Pass the process data to your run_widget (assuming it expects a dict)
        self.run_widget.start_process(new_process)

        # Switch the UI to the run widget
        self.stacked.setCurrentWidget(self.run_widget)

        self.populate_load_table()

    def load_process_from_instance(self):
        pass
    # def populate_load_table(self):
    #     print(1)
    #     # Clear existing contents and reset row/column counts
    #     self.save_and_load_widget.clearContents()
    #     self.save_and_load_widget.setRowCount(0)
    #     self.save_and_load_widget.setColumnCount(0)
    #
    #     query = {
    #         "complete": False,
    #         "status": {"$ne": "deleted"}  # Exclude deleted
    #     }
    #     results = list(self.answer_collection.find(query))
    #     print(5555, results)
    #     if not results:
    #         return
    #
    #     # Set row and column counts based on results
    #     self.save_and_load_widget.setRowCount(len(results))
    #     # Use keys from first document as column headers (exclude _id if desired)
    #     keys = list(results[0].keys())
    #     self.save_and_load_widget.setColumnCount(len(keys))
    #     self.save_and_load_widget.setHorizontalHeaderLabels(keys)
    #
    #     # Populate table
    #     for row, entry in enumerate(results):
    #         for col, key in enumerate(keys):
    #             value = entry.get(key, "")
    #             text = str(value)
    #
    #             # Create a preview if text is long
    #             preview = text if len(text) <= 40 else text[:37] + "..."
    #
    #             item = QTableWidgetItem(preview)
    #             # Make cell non-editable
    #             item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
    #             # Tooltip shows full text on hover
    #             item.setToolTip(text)
    #
    #             self.save_and_load_widget.setItem(row, col, item)
    #
    #         # Store the MongoDB _id (as string) in the first column's UserRole data for access later
    #         id_item = self.save_and_load_widget.item(row, 0)
    #         if id_item:
    #             id_item.setData(Qt.UserRole, str(entry.get("_id", "")))

    def populate_load_table(self):

        print(1199,self.processes_pending)

        # Clear the table first
        self.save_and_load_widget.clearContents()
        self.save_and_load_widget.setRowCount(0)
        self.save_and_load_widget.setColumnCount(0)

        if not hasattr(self, "processes_pending") or not self.processes_pending:
            return

        processes = self.processes_pending

        # Convert all processes to dictionaries
        process_dicts = [p.to_dict() for p in processes]

        if not process_dicts:
            return

        # Use keys from the first process for headers
        keys = list(process_dicts[0].keys())
        self.save_and_load_widget.setColumnCount(len(keys))
        self.save_and_load_widget.setHorizontalHeaderLabels(keys)
        self.save_and_load_widget.setRowCount(len(process_dicts))

        for row, data in enumerate(process_dicts):
            for col, key in enumerate(keys):
                value = data.get(key, "")
                text = str(value)
                preview = text if len(text) <= 40 else text[:37] + "..."

                item = QTableWidgetItem(preview)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                item.setToolTip(text)
                self.save_and_load_widget.setItem(row, col, item)

            # Store process_id in the UserRole of the first column
            id_item = self.save_and_load_widget.item(row, 0)
            if id_item:
                id_item.setData(Qt.UserRole, data.get("process_id", ""))

    def populate_load_table(self):

        # Clear the table
        self.save_and_load_widget.clearContents()
        self.save_and_load_widget.setRowCount(0)
        self.save_and_load_widget.setColumnCount(0)

        if not hasattr(self, "processes_pending") or not self.processes_pending:
            return

        processes = self.processes_pending

        if not processes:
            return

        # Use the attributes of the first process for column headers
        first_process = processes[0]
        keys = [attr for attr in vars(first_process)]
        self.save_and_load_widget.setColumnCount(len(keys))
        self.save_and_load_widget.setHorizontalHeaderLabels(keys)
        self.save_and_load_widget.setRowCount(len(processes))

        for row, process in enumerate(processes):
            for col, key in enumerate(keys):
                value = getattr(process, key, "")
                text = str(value)
                preview = text if len(text) <= 40 else text[:37] + "..."

                item = QTableWidgetItem(preview)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                item.setToolTip(text)
                self.save_and_load_widget.setItem(row, col, item)

            # Store the entire process instance in the first column's UserRole
            id_item = self.save_and_load_widget.item(row, 0)
            if id_item:
                id_item.setData(Qt.UserRole, process)

    def populate_load_table(self):
        self.save_and_load_widget.clearContents()
        self.save_and_load_widget.setRowCount(0)
        self.save_and_load_widget.setColumnCount(0)

        if not hasattr(self, "processes_pending") or not self.processes_pending:
            return

        processes = self.processes_pending
        if not processes:
            return

        # Only show selected fields
        keys = ["title", "start_date","status"]
        self.save_and_load_widget.setColumnCount(len(keys))
        self.save_and_load_widget.setHorizontalHeaderLabels(keys)
        self.save_and_load_widget.setRowCount(len(processes))

        for row, process in enumerate(processes):
            tooltip_lines = []

            # Prepare tooltip: Tasks
            if hasattr(process, "tasks"):
                tooltip_lines.append("Tasks:")
                for task in process.tasks:
                    q = getattr(task, "question", "N/A")
                    a = getattr(task, "answer", "—")
                    tooltip_lines.append(f"- {q}: {a}")

            # Prepare tooltip: Todos
            if hasattr(process, "todos"):
                tooltip_lines.append("\nTodos:")
                for todo in process.todos:
                    title = getattr(todo, "title", "N/A")
                    checked = getattr(todo, "checked", False)
                    status = "✓" if checked else "✗"
                    tooltip_lines.append(f"- [{status}] {title}")

            full_tooltip = "\n".join(tooltip_lines)

            for col, key in enumerate(keys):
                value = getattr(process, key, "")
                text = str(value)
                item = QTableWidgetItem(text)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                item.setToolTip(full_tooltip)
                self.save_and_load_widget.setItem(row, col, item)

            # Store full process in UserRole of first column
            id_item = self.save_and_load_widget.item(row, 0)
            if id_item:
                id_item.setData(Qt.UserRole, process)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
