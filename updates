import sys
import uuid

from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QLabel, QStackedWidget, QGridLayout, QShortcut, QMessageBox
)
from PyQt5.QtGui import QFont, QMouseEvent, QKeySequence
from PyQt5.QtCore import Qt, QPoint, QTimer
from PyQt5.QtWidgets import (
    QWidget, QLabel, QListWidget, QPushButton,
    QVBoxLayout, QHBoxLayout, QListWidgetItem, QLineEdit, QDialog, QComboBox, QCheckBox, QScrollArea, QMenu, QAction, QColorDialog,QTextEdit, QTextBrowser
)
from PATH import uri

from pymongo import MongoClient
from datetime import datetime
import ast

class SelectionDialog(QDialog):
    def __init__(self, items, parent=None, title="Select an Option", label="Choose one:"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.selected_item = None


        layout = QVBoxLayout(self)

        layout.addWidget(QLabel(label))

        self.combo_box = QComboBox()
        # Populate combo with title as display, full dict as user data
        for key, value in items.items():
            self.combo_box.addItem(value.get("title", str(key)), value)

        layout.addWidget(self.combo_box)

        # Buttons
        button_layout = QHBoxLayout()
        confirm_button = QPushButton("Confirm")
        cancel_button = QPushButton("Cancel")
        button_layout.addWidget(confirm_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        confirm_button.clicked.connect(self.confirm)
        cancel_button.clicked.connect(self.reject)

    def confirm(self):
        self.selected_item = self.combo_box.currentData()
        self.accept()

    def get_selection(self):
        return self.selected_item


class RightClickableButton(QPushButton):
    def __init__(self,main,button_pos,load_color = None,load_id = None, text="", parent=None):
        super().__init__(text, parent)

        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self.main = main
        self.color = None
        self.button_pos = button_pos
        if load_id:
            self.id = load_id
            self.update_button()
        else:
            self.id = None
        if load_color:
            self.color = load_color
            self.update_button()
        self.prior_id = None


    def show_context_menu(self, pos: QPoint):
        global_pos = self.mapToGlobal(pos)

        menu = QMenu(self)

        action_1 = QAction("Set Quicklink", self)
        action_1.triggered.connect(self.set_quicklink)

        action_2 = QAction("Custom Action 2", self)
        action_2.triggered.connect(self.get_color)

        menu.addAction(action_1)
        menu.addAction(action_2)

        menu.exec_(global_pos)

    def set_quicklink(self):
        try:
            if self.id:
                self.prior_id = self.id
            dialog = SelectionDialog(self.main.process_data,self.main, title="Pick Quicklink for button")
            if dialog.exec_() == QDialog.Accepted:
                self.id = dialog.get_selection()["process_id"]
                self.main.process_data[self.id]["button_position"] = self.button_pos
                self.color = None
                self.main.process_collection.update_one(
                    {"idkey": self.id},
                    {"$set": self.main.process_data[self.id]},
                    upsert=True
                )
                if self.prior_id:
                    del self.main.process_data[self.prior_id]["button_position"]
                    del self.main.process_data[self.prior_id]["button_color"]
                    self.main.process_collection.update_many(
                        {"idkey": self.prior_id},
                        {"$unset": {"button_position": "", "button_color": ""}}
                    )
                self.update_button()


            else:
                print("Cancelled")
        except Exception as err:
            print(err)

    def get_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.color = color.name()
            self.update_button()
            self.main.process_data[self.id]["button_color"] = self.color
            self.main.process_collection.update_one(
                {"idkey": self.id},
                {"$set": self.main.process_data[self.id]},
                upsert=True
            )
            return None  # Returns color as hex string, e.g. "#ff0000"
        return None

    def update_button(self):
        self.setText(self.main.process_data[self.id]["title"])
        self.setStyleSheet(f"background-color: {self.color}")
        try:
            self.clicked.disconnect()
        except TypeError:
            # no connections were present
            pass
        self.clicked.connect(lambda: self.main.run_process(self.id))


        #self.layout()


# --- Sub-check widget with simple QCheckBox ---
class Subcheck(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        main_layout = QVBoxLayout(self)

        # Horizontal layout: checkbox + label
        top_row = QHBoxLayout()
        self.check_box = QCheckBox()
        self.check_box.setFixedSize(20, 20)
        self.check_box.stateChanged.connect(self.notify_parent)
        top_row.addWidget(self.check_box)

        self.check_label = QLabel("Check item:")
        self.check_label.setStyleSheet("font-size: 14pt;")
        self.check_label.setAlignment(Qt.AlignVCenter | Qt.AlignLeft)
        top_row.addWidget(self.check_label)

        top_row.addStretch()
        main_layout.addLayout(top_row)

        # Optional comment input
        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        main_layout.addWidget(self.comment_input)



    def notify_parent(self):
        if self.parent() and hasattr(self.parent(), "evaluate_progress"):
            self.parent().evaluate_progress()

    def get_data(self):
        return {
            "text": self.check_label.text(),
            "checked": self.check_box.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_box.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_box.setChecked(False)
        self.comment_input.clear()

# --- Checklist Manager Widget ---
class ChecklistManagerWidget(QWidget):
    def __init__(self, multicheck_input=None):
        super().__init__()
        self.setWindowTitle("Checklist Manager")
        self.setMinimumSize(400, 500)
        self.checks = []

        self.layout = QVBoxLayout(self)

        # Label to show current checklist title or prompt
        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        self.layout.addWidget(self.check_label)

        # Input area with button to add new check item
        add_layout = QHBoxLayout()
        self.check_input = QLineEdit()
        self.check_input.setPlaceholderText("Enter new check...")
        self.add_button = QPushButton("Add Check")
        self.add_button.clicked.connect(self.add_check)
        add_layout.addWidget(self.check_input)
        add_layout.addWidget(self.add_button)
        self.layout.addLayout(add_layout)

        # Scrollable container for check items (Subcheck widgets)
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.checks_container = QWidget()
        self.checks_layout = QVBoxLayout(self.checks_container)
        self.scroll_area.setWidget(self.checks_container)
        self.layout.addWidget(self.scroll_area)

        # Shortcuts for focusing input and confirming add
        focus_shortcut = QShortcut(QKeySequence("Alt+A"), self)
        focus_shortcut.activated.connect(self.check_input.setFocus)

        confirm_shortcut = QShortcut(QKeySequence("Alt+Return"), self)
        confirm_shortcut.activated.connect(self.add_check)

    def add_check(self):
        """
        Adds a new check item to the checklist if input text is not empty.
        Prevents adding empty or whitespace-only checks.
        """
        text = self.check_input.text()
        if text is None:
            # Defensive: text should not be None, but handle gracefully
            return
        text = text.strip()
        if not text:
            # Do not add empty checks
            return

        # Create new Subcheck widget and set its text safely
        try:
            widget = Subcheck(self.checks_container)
            if hasattr(widget, "set_check_text"):
                widget.set_check_text(text)
            else:
                # Defensive fallback: if Subcheck lacks method, skip adding
                return
        except Exception as e:
            print(f"Error creating or setting Subcheck widget: {e}")
            return

        # Add widget to layout and tracking list
        self.checks_layout.addWidget(widget)
        self.checks.append(widget)

        # Clear input field after adding
        self.check_input.clear()

        # Optionally, update validation state
        self.is_valid()

    def is_valid(self):
        """
        Returns True if all check widgets are valid.
        Empty checklist is considered valid by design.
        """
        if not self.checks:
            return True
        try:
            # Ensure all check widgets implement is_valid method and return True
            return all(
                (hasattr(check, "is_valid") and callable(check.is_valid) and check.is_valid())
                for check in self.checks
            )
        except Exception as e:
            print(f"Error validating checks: {e}")
            return False

    def get_data(self):
        """
        Returns a list of data collected from all Subcheck widgets.
        Returns empty list if no checks or on error.
        """
        try:
            return [
                check.get_data() if (hasattr(check, "get_data") and callable(check.get_data)) else None
                for check in self.checks
            ]
        except Exception as e:
            print(f"Error getting data from checks: {e}")
            return []

    def set_check_text(self, text):
        """
        Sets the checklist title or label text.
        """
        if text is None:
            text = ""
        self.check_label.setText(str(text))

    def reset(self):
        """
        Removes all Subcheck widgets and clears the checklist.
        """
        # Remove widgets safely
        for check in self.checks:
            try:
                check.setParent(None)
                check.deleteLater()
            except Exception as e:
                print(f"Error removing check widget: {e}")

        # Clear internal list of check widgets
        self.checks.clear()

        # Clear input text field
        self.check_input.clear()

        # Update layout to reflect changes
        self.checks_layout.update()

    def load_checks(self, checks_list):
        """
        Loads a list of checks into the widget, replacing existing checks.
        Expects checks_list to be a list of strings; ignores invalid data.
        """
        self.reset()

        # Defensive check for input type
        if not isinstance(checks_list, list):
            print("load_checks expects a list of strings")
            return

        # Add each check text safely
        for text in checks_list:
            if not isinstance(text, str):
                # Skip non-string items to avoid errors
                continue
            try:
                widget = Subcheck(self.checks_container)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
                else:
                    continue
                self.checks_layout.addWidget(widget)
                self.checks.append(widget)
            except Exception as e:
                print(f"Error adding Subcheck in load_checks: {e}")



#TODO neuer fenster bestandteil, wo man die einzelnen
#TODO Final View machen, wo alles zusammengefasst wird und eine möglichkeit für ein Exitbriefing gegeben wird

class DoubleClickCheckButton(QPushButton):
    def __init__(self, text=""):
        super().__init__(text)
        self.setCheckable(True)
        self.setMinimumHeight(80)
        self.setStyleSheet("background-color: none")

    def mousePressEvent(self, event: QMouseEvent):
        # Prevent single clicks from toggling
        event.ignore()

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        # Only toggle on double-click
        self.setChecked(not self.isChecked())
        self.update_style()

    def update_style(self):
        if self.isChecked():
            self.setStyleSheet("background-color: lightgreen")
        else:
            self.setStyleSheet("background-color: none")
class QuestionStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.question_label = QLabel("Question goes here")
        self.question_label.setAlignment(Qt.AlignCenter)
        self.question_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.question_label)

        self.answer_input = QLineEdit()
        self.answer_input.setPlaceholderText("Your answer (required)")
        layout.addWidget(self.answer_input)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        self.answer_input.setFocus()

    def get_data(self):
        return {
            "answer": self.answer_input.text().strip(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return bool(self.answer_input.text().strip())

    def set_question_text(self, text):
        self.question_label.setText(text)
        self.answer_input.clear()
        self.comment_input.clear()

class CheckStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.check_label)

        self.check_button = DoubleClickCheckButton("Check Off")
        layout.addWidget(self.check_button)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        # Ctrl + Space shortcut to toggle check
        toggle_shortcut = QShortcut(QKeySequence("Ctrl+Space"), self)
        toggle_shortcut.activated.connect(self.toggle_check_button)

    def toggle_check_button(self):
        self.check_button.setChecked(not self.check_button.isChecked())
        self.check_button.update_style()

    def get_data(self):
        return {
            "checked": self.check_button.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_button.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_button.setChecked(False)
        self.check_button.update_style()
        self.comment_input.clear()


class RunProcessWidget(QWidget):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.process_id = None
        self.current_index = 0
        self.process_data = None
        self.process_tracking = None
        self.step_widgets = {}

        # === Outer Layout: Main content (left) + Hints (right) ===
        outer_layout = QHBoxLayout(self)
        self.setLayout(outer_layout)

        # === Left Main Content Area ===
        main_layout = QVBoxLayout()
        main_container = QWidget()
        main_container.setLayout(main_layout)
        outer_layout.addWidget(main_container, 3)  # Stretch factor 3 for main area

        self.title_label = QLabel("Run Process")
        self.title_label.setFont(QFont("Arial", 16, QFont.Bold))
        self.title_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.title_label)

        self.sub_label = QLabel("Step will show here")
        self.sub_label.setFont(QFont("Arial", 12))
        self.sub_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.sub_label)

        self.step_container = QStackedWidget()
        main_layout.addWidget(self.step_container)

        self.widgets_by_type = {
            "question": QuestionStepWidget(),
            "check": CheckStepWidget(),
            "subcheck": ChecklistManagerWidget(),
            "multicheck": ChecklistManagerWidget()
        }

        for widget in self.widgets_by_type.values():
            self.step_container.addWidget(widget)

        nav_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.cancel_process)
        nav_layout.addWidget(self.cancel_button)

        self.back_button = QPushButton("Back")
        self.back_button.clicked.connect(self.go_back)
        nav_layout.addWidget(self.back_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_next_or_finish)
        nav_layout.addWidget(self.next_button)

        # Add keyboard shortcuts
        QShortcut(QKeySequence("Ctrl+Return"), self, self.next_button.click)
        QShortcut(QKeySequence("Ctrl+Backspace"), self, self.back_button.click)

        main_layout.addLayout(nav_layout)

        # === Right Side: Hints Panel ===
        self.hints_browser = QTextBrowser()
        self.hints_browser.setMinimumWidth(250)
        self.hints_browser.setStyleSheet("background-color: #f7f7f7; padding: 10px; font-size: 11pt;")
        self.hints_browser.setOpenExternalLinks(True)
        outer_layout.addWidget(self.hints_browser, 1)  # Stretch factor 1 for hints

        # Define static hints per step type
        self.hint_texts = {
            "question": "<b>Hint:</b> Read the question carefully before responding.",
            "check": "<b>Hint:</b> Make sure the stated condition is met.",
            "subcheck": "<b>Hint:</b> Check each sub-item after reviewing it.",
            "multicheck": "<b>Hint:</b> Select all applicable items for the current step."
        }

    def update_view(self):
        """
        Update the visible step and display relevant hints.
        Includes extensive safety checks.
        """
        steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
        if not steps or not isinstance(steps, list) or not (0 <= self.current_index < len(steps)):
            return

        current_step = steps[self.current_index]
        if not isinstance(current_step, dict):
            return

        step_type = current_step.get("type")
        text = current_step.get("text", "No text")

        self.sub_label.setText(f"Step {self.current_index + 1} of {len(steps)}")

        widget = self.widgets_by_type.get(step_type)
        if not widget:
            return

        try:
            if step_type == "question" and hasattr(widget, "set_question_text"):
                widget.set_question_text(text)
            elif step_type == "check" and hasattr(widget, "set_check_text"):
                widget.set_check_text(text)
            elif step_type == "subcheck":
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
                if hasattr(widget, "reset"):
                    widget.reset()
            elif step_type == "multicheck":
                items = current_step.get("items", [])
                if not isinstance(items, list):
                    items = []
                if hasattr(widget, "load_checks"):
                    widget.load_checks(items)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
        except Exception as e:
            print(f"Error updating widget: {e}")
            return

        self.step_container.setCurrentWidget(widget)

        # --- Dynamic hint update ---
        hints = current_step.get("hints")
        if isinstance(hints, list) and hints:
            # Join each hint line as a separate bullet point or paragraph
            html = "<b>Hints:</b><br>" + "<br>".join(f"&bull; {line}" for line in hints)
        elif isinstance(hints, str) and hints.strip():
            html = f"<b>Hint:</b> {hints.strip()}"
        else:
            # Fallback to static hints
            html = self.hint_texts.get(step_type, "<i>No hints for this step.</i>")

        self.hints_browser.setHtml(html)

    def go_next_or_finish(self):
        """
        Validate current step, store result, and advance to next or finish.
        """
        steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
        if not steps or not (0 <= self.current_index < len(steps)):
            print("Invalid process state.")
            return

        current_step = steps[self.current_index]
        if not isinstance(current_step, dict):
            print("Malformed step.")
            return

        step_type = current_step.get("type")
        widget = self.widgets_by_type.get(step_type)
        if not widget or not callable(getattr(widget, "is_valid", None)) or not widget.is_valid():
            print("Invalid input for current step.")
            return

        if self.process_tracking is None:
            self.process_tracking = {"responses": []}

        try:
            data = widget.get_data() if callable(getattr(widget, "get_data", None)) else None
        except Exception as e:
            print(f"Error retrieving widget data: {e}")
            return

        self.process_tracking["responses"].append({
            "step": self.current_index,
            "type": step_type or "",
            "data": data
        })

        self.current_index += 1

        if self.current_index < len(steps):
            self.update_view()
        else:
            # Finalize process
            self.process_tracking["status"] = "Completed"
            self.process_tracking["end_time"] = datetime.now()
            try:
                if hasattr(self.main, "answer_collection"):
                    self.main.answer_collection.insert_one(self.process_tracking)
            except Exception as e:
                print(f"Error saving to DB: {e}")

            try:
                if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
                    self.main.stacked.setCurrentWidget(self.main.grid_widget)
            except Exception as e:
                print(f"Error switching to grid widget: {e}")

    def go_back(self):
        """Move back one step if possible."""
        if self.current_index > 0:
            self.current_index -= 1
            self.update_view()

    def cancel_process(self):
        """Cancel the process and record status."""
        if self.process_tracking is not None:
            self.process_tracking["status"] = "Cancelled"
            self.process_tracking["end_time"] = datetime.now()
            try:
                if hasattr(self.main, "answer_collection"):
                    self.main.answer_collection.insert_one(self.process_tracking)
            except Exception as e:
                print(f"Error saving cancellation data: {e}")

        self.process_id = None
        self.process_tracking = None

        try:
            if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
                self.main.stacked.setCurrentWidget(self.main.grid_widget)
        except Exception as e:
            print(f"Error switching UI on cancel: {e}")

    def start_process(self, process_data):
        """Initialize a new process with the provided process_data dict."""
        if not isinstance(process_data, dict):
            print("start_process: Invalid input.")
            return

        self.process_data = process_data
        self.current_index = 0
        self.process_tracking = {
            "start_time": datetime.now(),
            "title": process_data.get("title", "Untitled"),
            "responses": []
        }

        self.update_view()
class MainGridWidget(QWidget):
    def __init__(self,main):
        super().__init__()
        self.layout = QGridLayout(self)
        self.main = main
        self.populate_grid()

    def populate_grid(self):
        print(self.main.process_data)
        for i in range(5):
            for j in range(5):
                button_id = None  # Reset at the start of each grid cell
                color = None
                for key, subdict in self.main.process_data.items():
                    if subdict.get("button_position") == [i, j]:
                        button_id = key
                        color = subdict.get("button_color")
                        break  # Stop after finding the first match

                button = RightClickableButton(self.main, (i, j), load_color=color, load_id = button_id)
                self.layout.addWidget(button, i, j)



class AddSubDialog(QDialog):
    def __init__(self, parent=None, edit=None):
        super().__init__(parent)
        self.setWindowTitle("Add New Sub")
        self.setModal(True)
        self.setMinimumWidth(300)
        self.edit = edit  # Optional dict for editing an existing step

        layout = QVBoxLayout(self)

        # --- Type selection combo box ---
        layout.addWidget(QLabel("Sub Type:"))
        self.type_combo = QComboBox()
        self.type_combo.addItems(["question", "check", "subcheck", "multicheck"])
        layout.addWidget(self.type_combo)

        # --- Dynamic container for input fields ---
        self.input_container = QVBoxLayout()
        layout.addLayout(self.input_container)

        # --- OK / Cancel Buttons ---
        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)

        # Signal connections
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.ok_button.setEnabled(False)  # Disabled until input is valid

        if edit:
            type_str = edit.get("type", "")
            index = self.type_combo.findText(type_str, Qt.MatchFixedString)
            self.type_combo.setCurrentIndex(index if index >= 0 else 0)
        else:
            self.type_combo.setCurrentIndex(0)

        self.type_combo.currentIndexChanged.connect(self.rebuild_entry)

        self.rebuild_entry()

        if edit:
            QTimer.singleShot(0, self.prefill_edit)

    def prefill_edit(self):
        subtype = self.type_combo.currentText()
        text = self.edit.get("text", "")

        if subtype == "multicheck":
            title = self.edit.get("text", "")
            items = self.edit.get("items", [])
            if self.text_title:
                self.text_title.setText(title)
            if self.text_widget and isinstance(items, list):
                self.text_widget.setPlainText("\n".join(items))
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit) and isinstance(text, str):
                self.text_widget.setText(text)

        # --- Prefill hint field if available ---
        hints = self.edit.get("hints", [])
        if isinstance(hints, list) and self.hint_widget:
            self.hint_widget.setPlainText("\n".join(hints))

    def validate_input(self):
        subtype = self.type_combo.currentText()
        valid = False

        if subtype == "multicheck":
            if self.text_title and self.text_widget:
                valid = bool(self.text_title.text().strip() and self.text_widget.toPlainText().strip())
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit):
                valid = bool(self.text_widget.text().strip())

        self.ok_button.setEnabled(valid)

    def get_data(self):
        subtype = self.type_combo.currentText()

        # Parse hints from QTextEdit into list of trimmed non-empty lines
        hints = []
        if self.hint_widget:
            hints = [
                line.strip() for line in self.hint_widget.toPlainText().splitlines() if line.strip()
            ]

        if subtype == "multicheck":
            if not self.text_title or not self.text_widget:
                return {"type": subtype, "text": "", "items": [], "hints": hints}
            title = self.text_title.text().strip()
            items = [
                line.strip() for line in self.text_widget.toPlainText().splitlines() if line.strip()
            ]
            return {
                "type": subtype,
                "text": title,
                "items": items,
                "hints": hints
            }
        else:
            text = self.text_widget.text().strip() if self.text_widget else ""
            return {
                "type": subtype,
                "text": text,
                "hints": hints
            }

    def rebuild_entry(self):
        # Clear all widgets from the input container
        for i in reversed(range(self.input_container.count())):
            widget = self.input_container.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # Reset references
        self.text_widget = None
        self.text_title = None
        self.hint_widget = None

        subtype = self.type_combo.currentText()

        if subtype == "multicheck":
            self.input_container.addWidget(QLabel("Checklist Title:"))
            self.text_title = QLineEdit()
            self.text_title.setPlaceholderText("Enter checklist title...")
            self.input_container.addWidget(self.text_title)

            self.input_container.addWidget(QLabel("Checklist Items:"))
            self.text_widget = QTextEdit()
            self.text_widget.setPlaceholderText("Enter multiple options, one per line...")
            self.input_container.addWidget(self.text_widget)

            self.text_title.textChanged.connect(self.validate_input)
            self.text_widget.textChanged.connect(self.validate_input)
        else:
            self.input_container.addWidget(QLabel("Text:"))
            self.text_widget = QLineEdit()
            self.text_widget.setPlaceholderText("Enter sub-process text...")
            self.input_container.addWidget(self.text_widget)
            self.text_widget.textChanged.connect(self.validate_input)

        # --- Add hint input field for all types ---
        self.input_container.addWidget(QLabel("Hints (one per line):"))
        self.hint_widget = QTextEdit()
        self.hint_widget.setPlaceholderText("Enter optional hints for this step...")
        self.input_container.addWidget(self.hint_widget)

        self.validate_input()
class EditProcessesWidget(QWidget):
    def __init__(self, main):
        super().__init__()

        self.main = main

        # Main layout
        main_layout = QVBoxLayout(self)

        # Header label styled as a header
        header = QLabel("Edit Processes View")
        header.setFont(QFont("Arial", 16, QFont.Bold))
        header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(header)

        # Horizontal layout: list on left, buttons on right
        content_layout = QHBoxLayout()

        # Left side: process list (single-select)
        self.process_list = QListWidget()
        self.process_list.setSelectionMode(QListWidget.SingleSelection)
        for key in self.main.process_data.keys():
            list_item = QListWidgetItem(self.main.process_data[key]["title"])  # show only the title
            list_item.setData(Qt.UserRole, key)  # store full dict
            self.process_list.addItem(list_item)
        content_layout.addWidget(self.process_list)

        # Right side: buttons
        button_layout = QVBoxLayout()

        self.run_button = QPushButton("Run")
        self.run_button.clicked.connect(self.run_process)
        button_layout.addWidget(self.run_button)

        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.add_process)
        button_layout.addWidget(self.add_button)

        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self.edit_process)
        button_layout.addWidget(self.edit_button)

        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_process)
        button_layout.addWidget(self.delete_button)

        content_layout.addLayout(button_layout)

        # Add content to main layout
        main_layout.addLayout(content_layout)

    # === Button Handlers ===
    def run_process(self):
        selected_item = self.process_list.currentItem()
        if selected_item is None:
            QMessageBox.warning(self, "No Selection", "Please select a process to run.")
            return

        process_id = selected_item.data(Qt.UserRole)
        self.main.run_process(process_id)

    def add_process(self):
        try:
            self.main.stacked.setCurrentWidget(self.main.new_widget)
            self.main.new_widget.process_id = str(uuid.uuid4())
            self.main.process_data[self.main.new_widget.process_id] = {"process_id":self.main.new_widget.process_id,"title":"new process","sub_process_data":[]}
            print(self.main.process_data)
        except Exception as err:
            print(888, str(err))

    def edit_process(self):

        selected_item = self.process_list.currentItem()
        process_id = selected_item.data(Qt.UserRole)
        self.process_id = process_id
        self.main.new_widget.process_id = self.process_id
        self.main.stacked.setCurrentWidget(self.main.new_widget)
        self.main.new_widget.title_input.setText(self.main.process_data[self.process_id]["title"])
        self.main.new_widget.subs_list.clear()
        for entry in self.main.process_data[self.process_id]["sub_process_data"]:
            self.main.new_widget.subs_list.addItem(str(entry))

        if not self.process_id:
            print("No process selected for editing.")
            return

        # Get the stored process ID from the item




    def delete_process(self):
        print("Delete")

class NewProcessWidget(QWidget):
    def __init__(self, main):
        super().__init__()

        if not hasattr(self, 'process_id'):
            self.process_id = None

        self.main = main  # reference to main window

        main_layout = QVBoxLayout(self)

        # Header
        self.header = QLabel("New Process View")
        self.header.setFont(QFont("Arial", 16, QFont.Bold))
        self.header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.header)

        # Title input + confirm button in a row
        title_row = QHBoxLayout()
        title_label = QLabel("Title:")
        self.title_input = QLineEdit()
        confirm_title_button = QPushButton("Confirm Title")
        confirm_title_button.clicked.connect(self.confirm_title)
        title_row.addWidget(title_label)
        title_row.addWidget(self.title_input)
        title_row.addWidget(confirm_title_button)
        main_layout.addLayout(title_row)

        # Horizontal layout: subs list on left, buttons on right
        content_layout = QHBoxLayout()

        # Sub-processes list
        subs_layout = QVBoxLayout()
        subs_label = QLabel("Sub-Processes:")
        subs_layout.addWidget(subs_label)

        self.subs_list = QListWidget()
        self.subs_list.setSelectionMode(QListWidget.SingleSelection)
        subs_layout.addWidget(self.subs_list)
        content_layout.addLayout(subs_layout)

        # Buttons layout (vertical)
        button_layout = QVBoxLayout()
        buttons = [
            ("Add", self.add_clicked),
            ("Edit", self.edit_clicked),
            ("Delete", self.delete_clicked),
            ("Up", self.up_clicked),
            ("Down", self.down_clicked),
        ]

        for text, handler in buttons:
            btn = QPushButton(text)
            btn.clicked.connect(handler)
            button_layout.addWidget(btn)

        button_layout.addStretch()  # push buttons to top
        content_layout.addLayout(button_layout)

        main_layout.addLayout(content_layout)

        # Bottom buttons: Cancel and Confirm
        bottom_buttons_layout = QHBoxLayout()
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.cancel_clicked)
        bottom_buttons_layout.addWidget(cancel_button)

        confirm_button = QPushButton("Confirm")
        confirm_button.clicked.connect(self.confirm_clicked)
        bottom_buttons_layout.addWidget(confirm_button)

        main_layout.addLayout(bottom_buttons_layout)

    # Button handlers (just print labels)

    def confirm_title(self):
        title = self.title_input.text()
        self.header.setText(title if title else "New Process View")
        self.main.process_data[self.process_id]["title"] = title
        self.main.save_process_to_mdb(self.process_id)

    def add_clicked(self):
        dialog = AddSubDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()
            self.main.process_data[self.process_id]["sub_process_data"].append(data)
            self.main.save_process_to_mdb(self.process_id)
            # self.temp["questions"] = self.temp["questions"] + [data]
            self.subs_list.clear()
            for entry in self.main.process_data[self.process_id]["sub_process_data"]:
                 self.subs_list.addItem(str(entry))

    def edit_clicked(self):
        selected_item = self.subs_list.currentItem()
        selected_index = self.subs_list.currentRow()
        d = ast.literal_eval(selected_item.text())
        dialog = AddSubDialog(self,edit = d)
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()
            self.main.process_data[self.process_id]["sub_process_data"][selected_index] = data
            self.main.save_process_to_mdb(self.process_id)
            self.subs_list.clear()
            for entry in self.main.process_data[self.process_id]["sub_process_data"]:
                 self.subs_list.addItem(str(entry))



    def delete_clicked(self):
        print("Delete")

    def up_clicked(self):
        try:
            index = self.subs_list.currentRow()
            if index > 0:
                data = self.main.process_data[self.process_id]["sub_process_data"]
                data[index - 1], data[index] = data[index], data[index - 1]
                self.main.save_process_to_mdb(self.process_id)
                self.refresh_subs_list()
                self.subs_list.setCurrentRow(index - 1)
        except Exception as err:
            print(str(err))

    def down_clicked(self):
        index = self.subs_list.currentRow()
        data = self.main.process_data[self.process_id]["sub_process_data"]
        if 0 <= index < len(data) - 1:
            data[index + 1], data[index] = data[index], data[index + 1]
            self.main.save_process_to_mdb(self.process_id)
            self.refresh_subs_list()
            self.subs_list.setCurrentRow(index + 1)

    def refresh_subs_list(self):
        self.subs_list.clear()
        for entry in self.main.process_data[self.process_id]["sub_process_data"]:
            self.subs_list.addItem(str(entry))

    def cancel_clicked(self):
        # Switch back to edit processes widget
        self.main.stacked.setCurrentWidget(self.main.edit_widget)

        # Reset UI in NewProcessWidget
        self.main.new_widget.title_input.clear()
        self.main.new_widget.header.setText("New Process View")
        self.main.new_widget.subs_list.clear()

    def delete_clicked(self):
        selected_index = self.subs_list.currentRow()
        if selected_index >= 0:
            del self.main.process_data[self.process_id]["sub_process_data"][selected_index]
            self.main.save_process_to_mdb(self.process_id)
            self.subs_list.takeItem(selected_index)

    def confirm_clicked(self):
        title = self.title_input.text()
        subs = [self.subs_list.item(i).text() for i in range(self.subs_list.count())]

        print(f"Saving process with title: {title}")
        print("Sub-processes:", subs)

        self.main.edit_widget.process_list.clear()
        for key in self.main.process_data.keys():
            list_item = QListWidgetItem(self.main.process_data[key]["title"])  # show only the title
            list_item.setData(Qt.UserRole, key)  # store full dict
            self.main.edit_widget.process_list.addItem(list_item)

        # Reset UI in NewProcessWidget
        self.main.new_widget.title_input.clear()
        self.main.new_widget.header.setText("New Process View")
        self.main.new_widget.subs_list.clear()

        # Switch back to edit processes widget
        self.main.stacked.setCurrentWidget(self.main.edit_widget)
        self.main.save_process_to_mdb(self.process_id)

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Process Manager")
        self.resize(800, 600)


        self.uri = uri


        main_layout = QVBoxLayout(self)

        # init mongo connection
        client = MongoClient(self.uri)
        db = client["process_tool"]
        self.answer_collection = db["processes_completed"]
        self.answer_collection.insert_one({"title":"connection","time":datetime.now()})
        self.process_collection = db["processes"]

        self.process_data = {
            doc["idkey"]: doc
            for doc in self.process_collection.find()
            if "idkey" in doc  # optional safety check
        }

        # Top buttons (only 3 now)
        button_layout = QHBoxLayout()
        self.run_button = QPushButton("Run")
        self.grid_button = QPushButton("Main Grid")
        self.edit_button = QPushButton("Edit Processes")

        for btn in (self.grid_button, self.edit_button):
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # Stacked widget setup
        self.stacked = QStackedWidget()
        self.run_widget = RunProcessWidget(self)
        self.grid_widget = MainGridWidget(self)
        self.edit_widget = EditProcessesWidget(self)
        self.new_widget = NewProcessWidget(self)  # Still available if needed

        self.stacked.addWidget(self.run_widget)
        self.stacked.addWidget(self.grid_widget)
        self.stacked.addWidget(self.edit_widget)
        self.stacked.addWidget(self.new_widget)

        main_layout.addWidget(self.stacked)

        # Connect buttons to view changes
        self.run_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.run_widget))
        self.grid_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.grid_widget))
        self.edit_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.edit_widget))

        # Default view
        self.stacked.setCurrentWidget(self.grid_widget)

    def save_process_to_mdb(self, id):
        self.process_collection.update_one(
            {"idkey": id},
            {"$set": self.process_data[id]},
            upsert=True
        )

    def run_process(self,id):
        #print(22,self.process_data[id])
        self.stacked.setCurrentWidget(self.run_widget)
        self.run_widget.start_process(self.process_data[id])


if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())



--------------

import sys
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QComboBox, QDateEdit, QTextEdit, QLineEdit, QPushButton, QGridLayout, QSpinBox, QDialog, QAction, QLabel, QListWidget,QDialogButtonBox, QInputDialog,QMessageBox,
QListWidgetItem, QAbstractItemView, QCompleter, QShortcut,QMenu, QScrollArea
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QKeySequence
from pymongo import MongoClient
import uuid
from PATH import uri
from bson import ObjectId
import random

class BookDialog(QDialog):
    def __init__(self, main, tag_id,parent=None):
        super().__init__(parent)
        self.setWindowTitle("Show Notes for Tag")
        self.main = main
        self.setWindowTitle("Scrollable Text List")
        self.setMinimumSize(400, 300)

        # Outer layout
        layout = QVBoxLayout(self)

        # Scroll Area setup
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)

        self.texts = list(self.main.notes_col.find({"book_tags_id":tag_id}))

        # Add each text as a QLabel
        for text in self.texts:
            print(text)
            tag_string = ""
            seperator = "---------------"
            for tag in text.get("book_tags"):
                tag_string = tag_string + f"[{tag}]\t"
            string = text.get("source_text") + "\n" + f"{text.get("book_author")}, {text.get("book_title")}, S.{text.get("page")} \n {seperator} \n {tag_string} \n \n {text.get("comment_text")}"
            label = QLabel(string)
            label.setWordWrap(True)
            scroll_layout.addWidget(label)

        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)

        # Optional: Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)


class TagsDialog(QDialog):
    def __init__(self,main, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage Tags")


        self.main = main

        # Main layout
        main_layout = QVBoxLayout(self)

        # Header label
        header_label = QLabel("Tags")
        header_label.setStyleSheet("font-weight: bold; font-size: 16px;")
        main_layout.addWidget(header_label)

        # Row layout with list widget and buttons
        row_layout = QHBoxLayout()

        # Tag list
        self.tag_list = QListWidget()
        self.tag_list.setSelectionMode(QAbstractItemView.SingleSelection)

        row_layout.addWidget(self.tag_list, 2)

        self.tag_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tag_list.customContextMenuRequested.connect(self.open_context_menu)

        # Button layout (Add, Edit, Delete)
        button_layout = QVBoxLayout()
        self.add_button = QPushButton("Add")
        self.edit_button = QPushButton("Edit")
        self.delete_button = QPushButton("Delete")
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.edit_button)
        button_layout.addWidget(self.delete_button)
        button_layout.addStretch()
        row_layout.addLayout(button_layout, 1)

        main_layout.addLayout(row_layout)

        # Confirm and Cancel buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        main_layout.addWidget(button_box)

        # Connect button signals
        self.add_button.clicked.connect(self.add_tag)
        self.edit_button.clicked.connect(self.edit_tag)
        self.load_tags()

    def open_context_menu(self, position):
        selected_item = self.tag_list.itemAt(position)
        if selected_item is None:
            return

        menu = QMenu()
        set_group_action = menu.addAction("Set Group")
        show_notes_action = menu.addAction("Show Notes")

        action = menu.exec_(self.tag_list.viewport().mapToGlobal(position))

        if action == set_group_action:
            self.show_group_dialog(selected_item)
        elif action == show_notes_action:
            self.show_notes_dialog(selected_item)

    def show_notes_dialog(self,item):
        tag_id = item.data(Qt.UserRole)
        dialog = BookDialog(self.main,tag_id)
        dialog.exec_()

    def add_tag(self):
        text, ok = QInputDialog.getText(self, "Add Tag", "Enter tag name:")
        if ok and text:
            self.main.tags_col.insert_one({"id":str(uuid.uuid4()),"title":text})

        self.load_tags()

    def show_group_dialog(self, item):
        current_groups = sorted({tag.get("group", "") for tag in self.main.tags if tag.get("group")})
        current_groups.append("Add New Group...")

        group, ok = QInputDialog.getItem(
            self, "Set Group", "Select or add a group:", current_groups, editable=False
        )

        if ok and group:
            if group == "Add New Group...":
                group, ok = QInputDialog.getText(self, "New Group", "Enter new group name:")
                if not ok or not group:
                    return

            tag_id = item.data(Qt.UserRole)

            # Update in MongoDB
            self.main.tags_col.update_one({"id": tag_id}, {"$set": {"group": group}})

            # Reload tags with updated group info
            self.load_tags()

    def edit_tag(self):
        selected_items = self.tag_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "No Selection", "Please select a tag to edit.")
            return

        item = selected_items[0]
        current_title = item.text()
        tag_id = item.data(Qt.UserRole)

        # Show input dialog with current title pre-filled
        text, ok = QInputDialog.getText(self, "Edit Tag", "Edit tag name:", text=current_title)
        if ok and text:
            # Update in MongoDB
            self.main.tags_col.update_one({"id": tag_id}, {"$set": {"title": text}})
            # Update display
            item.setText(text)

            self.load_tags()

    def load_tags(self):
        self.main.update_tags()
        self.tag_list.clear()

        # Group tags by group name
        grouped_tags = {}
        for tag in self.main.tags:
            group = tag.get("group", "Ungrouped")
            grouped_tags.setdefault(group, []).append(tag)

        # Sort groups alphabetically
        for group_name in sorted(grouped_tags):
            # Add group header
            header_item = QListWidgetItem(f"Group: {group_name}")
            header_item.setFlags(Qt.ItemIsEnabled)  # not selectable
            header_item.setForeground(Qt.gray)
            header_item.setBackground(Qt.lightGray)
            header_item.setTextAlignment(Qt.AlignCenter)
            self.tag_list.addItem(header_item)

            # Add all tags in the group
            for tag in grouped_tags[group_name]:
                item = QListWidgetItem(f"  {tag['title']}")  # indent for clarity
                item.setData(Qt.UserRole, tag["id"])
                self.tag_list.addItem(item)

class Booknote():
    def __init__(self):
        self._id = None  # <-- this line
        self.book_title = None
        self.book_id = None
        self.book_author = None
        self.book_tags = []
        self.book_tags_id = []
        self.source_text = None
        self.comment_text = None
        self.page = None


    def add_tag(self,tag_name, tag_id):
        self.book_tags.append(tag_name)
        self.book_tags_id.append(id)


class TagWidget(QWidget):
    def __init__(self, title, remove_callback):
        super().__init__()

        # Validate input types
        if not isinstance(title, str):
            raise TypeError(f"TagWidget title must be a string, got: {type(title).__name__}")
        if not callable(remove_callback):
            raise TypeError("remove_callback must be a callable function.")

        # Create horizontal layout
        layout = QHBoxLayout(self)

        # Label showing the tag title
        self.label = QLabel(title)

        # Small "x" button to remove the tag
        self.remove_btn = QPushButton("x")
        self.remove_btn.setFixedSize(16, 16)

        # Add widgets to layout
        layout.addWidget(self.label)
        layout.addWidget(self.remove_btn)

        # Fine-tune spacing and margins for compact appearance
        layout.setContentsMargins(5, 2, 5, 2)
        layout.setSpacing(5)

        # Apply basic styling to the tag widget
        self.setStyleSheet("background-color: lightgray; border-radius: 5px; padding: 2px;")

        try:
            # Connect the remove button to the callback
            self.remove_btn.clicked.connect(lambda: remove_callback(title))
        except Exception as e:
            print(f"Failed to connect remove button for tag '{title}': {e}")




class TagEditor(QWidget):
    def __init__(self, main, tag_docs):
        super().__init__()
        self.main = main
        self.tag_docs = tag_docs

        self.used_ids = set()
        self.title_to_id = {}
        self.id_to_title = {}

        if not isinstance(tag_docs, list):
            raise ValueError("tag_docs must be a list of tag dictionaries.")

        self.build_title_to_id_keys()

        self.layout = QVBoxLayout(self)

        # Top layout (tags + input list)
        self.top_layout = QHBoxLayout()
        self.layout.addLayout(self.top_layout)

        # Tags display layout
        self.tags_layout = QHBoxLayout()
        self.top_layout.addLayout(self.tags_layout, stretch=3)

        # Right-side layout (input + list)
        self.right_panel_layout = QVBoxLayout()
        self.top_layout.addLayout(self.right_panel_layout, stretch=2)

        # Input for tag entry
        self.input = QLineEdit()
        self.input.setPlaceholderText("Select a tag title")
        self.right_panel_layout.addWidget(self.input)

        # Completer for autocomplete
        self.completer = QCompleter(sorted(self.title_to_id.keys()))
        self.completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.input.setCompleter(self.completer)

        # Tag list setup
        self.tag_list = QListWidget()
        self.tag_list.setFixedHeight(150)
        self.tag_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tag_list.customContextMenuRequested.connect(self.open_context_menu)
        self.right_panel_layout.addWidget(self.tag_list)

        self.populate_tag_list()

        # Event connections
        self.input.returnPressed.connect(self.add_tag_from_input)
        self.tag_list.itemClicked.connect(self.add_tag_from_list)

    def build_title_to_id_keys(self):
        try:
            self.title_to_id = {
                doc["title"]: doc["id"]
                for doc in self.tag_docs
                if isinstance(doc, dict) and "title" in doc and "id" in doc
            }
            self.id_to_title = {
                doc["id"]: doc["title"]
                for doc in self.tag_docs
                if isinstance(doc, dict) and "title" in doc and "id" in doc
            }
        except Exception as e:
            raise ValueError(f"Failed to process tag_docs: {e}")

    def populate_tag_list(self):
        self.tag_list.clear()
        grouped = {}

        for doc in self.tag_docs:
            if not isinstance(doc, dict):
                continue
            title = doc.get("title")
            tag_id = doc.get("id")
            group = doc.get("group", "Ungrouped")
            if title and tag_id:
                grouped.setdefault(group, []).append((title, tag_id))

        for group_name in sorted(grouped):
            header_item = QListWidgetItem(f"Group: {group_name}")
            header_item.setFlags(Qt.ItemIsEnabled)
            header_item.setForeground(Qt.gray)
            header_item.setBackground(Qt.lightGray)
            header_item.setTextAlignment(Qt.AlignCenter)
            self.tag_list.addItem(header_item)

            for title, tag_id in sorted(grouped[group_name]):
                item = QListWidgetItem(f"  {title}")
                item.setData(Qt.UserRole, tag_id)
                self.tag_list.addItem(item)

    def add_tag_from_input(self):
        title = self.input.text().strip()
        self.input.clear()

        if not title:
            print("No tag entered.")
            return

        tag_id = self.title_to_id.get(title)
        if tag_id is None:
            print(f"Tag '{title}' not found in available tags.")
            return

        if tag_id in self.used_ids:
            print(f"Tag '{title}' is already added.")
            return

        self.add_tag(title, tag_id)

    def add_tag_from_list(self, item):
        if item.text().strip().startswith("Group:"):
            return  # Skip group headers

        tag_id = item.data(Qt.UserRole)
        title = self.id_to_title.get(tag_id)

        if tag_id is None or title is None:
            print("Invalid tag selected.")
            return

        if tag_id in self.used_ids:
            print(f"Tag '{title}' is already added.")
            return

        self.add_tag(title, tag_id)

    def add_tag(self, title, tag_id):
        if not isinstance(title, str) or not isinstance(tag_id, str):
            print(f"Invalid tag data: title={title!r}, id={tag_id!r}")
            return

        if tag_id in self.used_ids:
            print(f"Tag '{title}' (ID: {tag_id}) is already in use.")
            return

        try:
            tag_widget = TagWidget(title.strip(), self.remove_tag)
            self.tags_layout.addWidget(tag_widget)
            self.used_ids.add(tag_id)
            print(f"Added tag: '{title}' (ID: {tag_id})")
        except Exception as e:
            print(f"Failed to add tag '{title}': {e}")

    def remove_tag(self, title):
        tag_id = self.title_to_id.get(title)
        if tag_id is None:
            print(f"Warning: Attempted to remove unknown tag title: '{title}'")
            return

        for i in reversed(range(self.tags_layout.count())):
            item = self.tags_layout.itemAt(i)
            if item is None:
                continue
            widget = item.widget()
            if widget and isinstance(widget, TagWidget) and widget.label.text().strip() == title:
                self.tags_layout.removeWidget(widget)
                widget.deleteLater()
                self.used_ids.discard(tag_id)
                print(f"Removed tag: '{title}' (ID: {tag_id})")
                break
        else:
            print(f"Warning: Tag widget for title '{title}' not found in layout.")

    def open_context_menu(self, position):
        selected_item = self.tag_list.itemAt(position)
        if selected_item is None:
            return

        if selected_item.text().strip().startswith("Group:"):
            return

        menu = QMenu()
        set_group_action = menu.addAction("Set Group")
        show_notes_action = menu.addAction("Show Notes")

        action = menu.exec_(self.tag_list.viewport().mapToGlobal(position))

        if action == set_group_action:
            self.show_group_dialog(selected_item)
        elif action == show_notes_action:
            self.show_notes_dialog(selected_item)

    def show_group_dialog(self, item):
        tag_id = item.data(Qt.UserRole)
        if tag_id is None:
            print("No tag ID found for selected item.")
            return

        current_groups = sorted({tag.get("group", "") for tag in self.main.tags if tag.get("group")})
        current_groups.append("Add New Group...")

        group, ok = QInputDialog.getItem(self, "Set Group", "Select or add a group:", current_groups, editable=False)

        if ok and group:
            if group == "Add New Group...":
                group, ok = QInputDialog.getText(self, "New Group", "Enter new group name:")
                if not ok or not group:
                    return

            self.main.tags_col.update_one({"id": tag_id}, {"$set": {"group": group}})
            self.load_tags()

    def show_notes_dialog(self, item):
        tag_id = item.data(Qt.UserRole)
        if tag_id is None:
            print("No tag ID found for selected item.")
            return

        dialog = BookDialog(self.main, tag_id)
        dialog.exec_()

    def get_selected_tag_ids(self):
        return list(self.used_ids)

    def clear_tags(self):
        for i in reversed(range(self.tags_layout.count())):
            item = self.tags_layout.itemAt(i)
            widget = item.widget()
            if widget:
                self.tags_layout.removeWidget(widget)
                widget.deleteLater()

        self.used_ids.clear()
        print("All tags cleared.")

class AddBookDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Book")

        # Layouts
        layout = QVBoxLayout(self)

        # Title input
        title_layout = QHBoxLayout()
        title_label = QLabel("Title:")
        self.title_input = QLineEdit()
        title_layout.addWidget(title_label)
        title_layout.addWidget(self.title_input)
        layout.addLayout(title_layout)

        # Author input
        author_layout = QHBoxLayout()
        author_label = QLabel("Name:")
        self.author_input = QLineEdit()
        author_layout.addWidget(author_label)
        author_layout.addWidget(self.author_input)
        fn_author_label = QLabel("First Name:")
        self.fn_author_input = QLineEdit()
        author_layout.addWidget(fn_author_label)
        author_layout.addWidget(self.fn_author_input)
        layout.addLayout(author_layout)

        # Buttons
        button_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        self.ok_button = QPushButton("Add Book")
        self.ok_button.clicked.connect(self.accept)
        button_layout.addWidget(self.cancel_button)
        button_layout.addWidget(self.ok_button)
        layout.addLayout(button_layout)

    def get_data(self):
        return {
            "title": self.title_input.text().strip(),
            "author": self.author_input.text().strip(),
            "first_name": self.fn_author_input.text().strip(),
            "book_id": str(uuid.uuid4())

        }


class ButtonPanel(QWidget):
    def __init__(self,main):
        super().__init__()
        layout = QVBoxLayout()
        self.main = main

        # 5 rows of buttons (1 per row, you can adjust for more per row)
        for i in range(5):
            row = QHBoxLayout()
            for j in range(3):  # 3 buttons per row for example
                btn = QPushButton(f"Button {i * 3 + j + 1}")
                row.addWidget(btn)
            layout.addLayout(row)

        # Input line below the buttons
        self.input_line = QLineEdit()
        layout.addWidget(self.input_line)

        completer = QCompleter([item["title"] for item in self.main.tags])
        self.input_line.setCompleter(completer)


        self.setLayout(layout)


class MainView(QMainWindow):
    def __init__(self):
        self.uri = uri

        self.client = MongoClient(self.uri)
        self.db = self.client["booknotes"]
        self.books_collection = self.db["sources"]
        self.tags_col = self.db["tags"]
        self.notes_col = self.db["notes"]

        self.current_note = Booknote()


        super().__init__()
        self.setWindowTitle("Main View Layout")
        self.setMinimumSize(600, 500)


        self.update_tags()



        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # Row 1: ComboBox + Date toggler
        row1 = QHBoxLayout()
        self.source_combo = QComboBox()
        self.source_combo.addItems(["Item 1", "Item 2", "Item 3"])

        row1.addWidget(self.source_combo)
        self.page_toggle = QSpinBox()
        self.page_toggle.setMinimum(-100)
        self.page_toggle.setMaximum(1000)
        self.page_toggle.setValue(1)  # default value
        row1.addWidget(self.page_toggle)
        main_layout.addLayout(row1)

        # Row 2: First multi-line input (5 lines)
        self.input_source_text = QTextEdit()
        self.input_source_text.setFixedHeight(100)
        self.input_source_text.setPlaceholderText("Enter source text here...")

        main_layout.addWidget(self.input_source_text)

        # Row 3: Second multi-line input (5 lines)
        self.input_comment_text = QTextEdit()
        self.input_comment_text.setFixedHeight(100)
        self.input_comment_text.setPlaceholderText("Enter comment here...")
        main_layout.addWidget(self.input_comment_text)

        # Row 4: Button panel with 5 rows of buttons + input line
        #self.button_panel = ButtonPanel(self)
        self.tag_widget = TagEditor(self,self.tags)
        main_layout.addWidget(self.tag_widget )

        # Row 5: Clear, Next, Finish buttons
        row5 = QHBoxLayout()
        self.clear_btn = QPushButton("Clear")
        self.next_btn = QPushButton("Next")
        #self.finish_btn = QPushButton("Finish")
        row5.addWidget(self.clear_btn)
        row5.addWidget(self.next_btn)
        #row5.addWidget(self.finish_btn)
        main_layout.addLayout(row5)

        self.setCentralWidget(central_widget)

        # Menu Bar
        menubar = self.menuBar()
        sources_menu = menubar.addMenu("Sources")
        tags_menu = menubar.addMenu("Tags")
        edit_menu = menubar.addMenu("Edit")


        create_tag_action = QAction("Manage Tags", self)
        create_tag_action.triggered.connect(self.open_tag_dialog)
        tags_menu.addAction(create_tag_action)

        create_source_action = QAction("Create Source", self)
        create_source_action.triggered.connect(self.open_add_book_dialog)
        sources_menu.addAction(create_source_action)

        edit_note_action = QAction("Edit Note", self)
        edit_note_action.triggered.connect(self.prompt_note_selection)
        edit_menu.addAction(edit_note_action)

        random_untagged_action = QAction("Edit Random Untagged Note", self)
        random_untagged_action.setShortcut("Ctrl+R")  # ← this line adds the shortcut
        random_untagged_action.triggered.connect(self.load_random_untagged_note)
        edit_menu.addAction(random_untagged_action)

        # Ctrl + + to increment page
        shortcut_inc = QShortcut(QKeySequence("Ctrl++"), self)
        shortcut_inc.activated.connect(self.increment_page)

        # Ctrl + - to decrement page
        shortcut_dec = QShortcut(QKeySequence("Ctrl+-"), self)
        shortcut_dec.activated.connect(self.decrement_page)

        self.next_btn.clicked.connect(self.next_clicked)

        # Ctrl + Return triggers the "Next" button
        shortcut_next = QShortcut(QKeySequence("Ctrl+Return"), self)
        shortcut_next.activated.connect(self.next_btn.click)


        self.update_items()

    def load_note_for_editing(self, note_id):
        note_doc = self.notes_col.find_one({"_id": ObjectId(note_id)})
        if not note_doc:
            print(f"[ERROR] Note with ID {note_id} not found.")
            return

        self.current_note = Booknote()
        self.current_note._id = note_doc["_id"]
        self.current_note.book_id = note_doc.get("book_id")
        self.current_note.page = note_doc.get("page")
        self.current_note.book_tags_id = note_doc.get("book_tags_id", [])
        self.current_note.source_text = note_doc.get("source_text", "")
        self.current_note.comment_text = note_doc.get("comment_text", "")

        # Set UI fields
        self.input_source_text.setPlainText(self.current_note.source_text)
        self.input_comment_text.setPlainText(self.current_note.comment_text)
        self.page_toggle.setValue(self.current_note.page or 0)

        # Set the correct book in the combo box
        index = self.source_combo.findData(self.current_note.book_id)
        if index >= 0:
            self.source_combo.setCurrentIndex(index)

        # Load tags into TagEditor
        self.tag_widget.clear_tags()
        self.update_tags()  # refresh tag list
        self.tag_widget.tag_docs = self.tags  # update tag editor with latest tags
        self.tag_widget.build_title_to_id_keys()  # rebuild ID maps

        for tag_id in self.current_note.book_tags_id:
            title = self.tag_widget.id_to_title.get(tag_id)
            if title:
                self.tag_widget.add_tag(title, tag_id)

    def next_clicked(self):
        """
        Triggered when the 'Next' button is clicked.
        Saves the current note, resets input fields, and initializes a new blank Booknote.
        """

        try:
            # Attempt to save the current note
            self.save_book_note()
        except Exception as e:
            print(f"[ERROR] Failed to save book note: {e}")

        # Clear input fields safely
        try:
            if hasattr(self, 'input_source_text') and self.input_source_text:
                self.input_source_text.clear()

            if hasattr(self, 'input_comment_text') and self.input_comment_text:
                self.input_comment_text.clear()
        except Exception as e:
            print(f"[ERROR] Failed to clear text inputs: {e}")

        # Clear tags in tag widget
        try:
            if hasattr(self, 'tag_widget') and self.tag_widget:
                self.tag_widget.clear_tags()
        except Exception as e:
            print(f"[ERROR] Failed to clear tags: {e}")

        # Reset current_note to a new blank instance
        try:
            self.current_note = Booknote()
        except Exception as e:
            print(f"[ERROR] Failed to initialize new Booknote: {e}")

        try:
            self.page_toggle.setFocus()
        except Exception as e:
            print(f"[ERROR] Failed to focus number toggler: {e}")



    def update_tags(self):
        self.tags = list(self.tags_col.find())

    def save_book_note(self):
        if not self.current_note:
            print("[ERROR] No current note set. Aborting save.")
            return

        try:
            self.current_note.book_tags_id = self.tag_widget.get_selected_tag_ids() or []

            id_to_title = {doc["id"]: doc["title"] for doc in self.tags}
            self.current_note.book_tags = [id_to_title.get(tid, "Unknown ID") for tid in self.current_note.book_tags_id]

            self.current_note.book_id = self.source_combo.currentData()

            book_doc = self.books_collection.find_one({"book_id": self.current_note.book_id})
            self.current_note.book_title = book_doc.get("title", "Unknown Title") if book_doc else "Unknown Title"
            last = book_doc.get("author", "Doe") if book_doc else "Doe"
            first = book_doc.get("first_name", "John") if book_doc else "John"
            self.current_note.book_author = f"{last}, {first}"

            self.current_note.source_text = self.input_source_text.toPlainText()
            self.current_note.comment_text = self.input_comment_text.toPlainText()
            self.current_note.page = self.page_toggle.value()

            note_doc = {
                'book_title': self.current_note.book_title,
                'book_id': self.current_note.book_id,
                'book_author': self.current_note.book_author,
                'book_tags': self.current_note.book_tags,
                'book_tags_id': self.current_note.book_tags_id,
                'source_text': self.current_note.source_text,
                'comment_text': self.current_note.comment_text,
                'page': self.current_note.page
            }

            if self.current_note._id:
                self.notes_col.update_one({"_id": self.current_note._id}, {"$set": note_doc})
                print(f"Updated note with ID {self.current_note._id}")
            else:
                result = self.notes_col.insert_one(note_doc)
                self.current_note._id = result.inserted_id
                print(f"Inserted new note with ID {result.inserted_id}")

            self.tag_widget.clear_tags()

        except Exception as e:
            print(f"[ERROR] Exception occurred while saving book note: {e}")
    def update_items(self):
        self.source_combo.clear()
        books = list(self.books_collection.find())
        for book in books:
            display_text = f"{book['author']}, {book['first_name']} - {book['title']}"
            self.source_combo.addItem(display_text, book["book_id"])

    def open_tag_dialog(self):
        dlg = TagsDialog(self)
        if dlg.exec_() == QDialog.Accepted:
            self.update_tags()
            self.tag_widget.tag_docs = self.tags
            self.tag_widget.build_title_to_id_keys()
            self.tag_widget.populate_tag_list()
            self.tag_widget.completer = QCompleter(sorted(self.tag_widget.title_to_id.keys()))
            self.tag_widget.input.setCompleter(self.tag_widget.completer)

    def prompt_note_selection(self):
        notes = list(self.notes_col.find().sort("book_title"))

        items = [f"{n.get('book_title', 'Untitled')} — Pg {n.get('page', '?')} (ID: {str(n['_id'])})" for n in notes]
        item, ok = QInputDialog.getItem(self, "Select Note", "Choose a note to edit:", items, 0, False)

        if ok and item:
            # Extract ID from the item string
            note_id = item.split("ID: ")[-1].strip(")")
            self.load_note_for_editing(note_id)

    def load_random_untagged_note(self):
        untagged_notes = list(self.notes_col.find({
            "$or": [
                {"book_tags_id": {"$exists": False}},
                {"book_tags_id": {"$size": 0}}
            ]
        }))

        if not untagged_notes:
            print("[INFO] No untagged notes found.")
            return

        random_note = random.choice(untagged_notes)
        self.load_note_for_editing(str(random_note["_id"]))

    def open_add_book_dialog(self):
        dialog = AddBookDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            book = dialog.get_data()
            query = {"author": book["author"], "title": book["title"]}

            # Data to insert/update
            update_data = book

            # Use upsert=True to insert if not found
            result = self.books_collection.update_one(
                query,
                {"$set": update_data},
                upsert=True
            )

            if result.matched_count > 0:
                print("Existing book updated.")
            else:
                print("New book inserted.")

            self.update_items()

            # Here you could insert into DB or update a list view

    def update_tags(self):
        self.tags = list(self.tags_col.find({}))

    def increment_page(self):
        current = self.page_toggle.value()
        self.page_toggle.setValue(current + 1)

    def decrement_page(self):
        current = self.page_toggle.value()
        self.page_toggle.setValue(current - 1)



    #def new_book_note(self):
    #    self.book

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainView()
    window.show()
    sys.exit(app.exec_())


