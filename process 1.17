import sys
import uuid
from bson import ObjectId

from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QLabel, QStackedWidget, QGridLayout, QShortcut, QMessageBox
)
from PyQt5.QtGui import QFont, QMouseEvent, QKeySequence
from PyQt5.QtCore import Qt, QPoint, QTimer
from PyQt5.QtWidgets import (
    QWidget, QLabel, QListWidget, QPushButton,QTableWidgetItem,
    QVBoxLayout, QHBoxLayout, QListWidgetItem,QTableWidget, QLineEdit, QDialog, QComboBox, QCheckBox, QScrollArea, QMenu, QAction, QColorDialog,QTextEdit, QTextBrowser
)
from PATH import uri

from pymongo import MongoClient
from datetime import datetime
import ast
#TODO Multichecks und Subchecks speichern und laden
class SelectionDialog(QDialog):
    def __init__(self, items, parent=None, title="Select an Option", label="Choose one:"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.selected_item = None


        layout = QVBoxLayout(self)

        layout.addWidget(QLabel(label))

        self.combo_box = QComboBox()
        # Populate combo with title as display, full dict as user data
        for key, value in items.items():
            self.combo_box.addItem(value.get("title", str(key)), value)

        layout.addWidget(self.combo_box)

        # Buttons
        button_layout = QHBoxLayout()
        confirm_button = QPushButton("Confirm")
        cancel_button = QPushButton("Cancel")
        button_layout.addWidget(confirm_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        confirm_button.clicked.connect(self.confirm)
        cancel_button.clicked.connect(self.reject)

    def confirm(self):
        self.selected_item = self.combo_box.currentData()
        self.accept()

    def get_selection(self):
        return self.selected_item


class RightClickableButton(QPushButton):
    def __init__(self,main,button_pos,load_color = None,load_id = None, text="", parent=None):
        super().__init__(text, parent)

        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self.main = main
        self.color = None
        self.button_pos = button_pos
        if load_id:
            self.id = load_id
            self.update_button()
        else:
            self.id = None
        if load_color:
            self.color = load_color
            self.update_button()
        self.prior_id = None


    def show_context_menu(self, pos: QPoint):
        global_pos = self.mapToGlobal(pos)

        menu = QMenu(self)

        action_1 = QAction("Set Quicklink", self)
        action_1.triggered.connect(self.set_quicklink)

        action_2 = QAction("Custom Action 2", self)
        action_2.triggered.connect(self.get_color)

        menu.addAction(action_1)
        menu.addAction(action_2)

        menu.exec_(global_pos)

    def set_quicklink(self):
        try:
            if self.id:
                self.prior_id = self.id
            dialog = SelectionDialog(self.main.process_data,self.main, title="Pick Quicklink for button")
            if dialog.exec_() == QDialog.Accepted:
                self.id = dialog.get_selection()["process_id"]
                self.main.process_data[self.id]["button_position"] = self.button_pos
                self.color = None
                self.main.process_collection.update_one(
                    {"idkey": self.id},
                    {"$set": self.main.process_data[self.id]},
                    upsert=True
                )
                if self.prior_id:
                    del self.main.process_data[self.prior_id]["button_position"]
                    del self.main.process_data[self.prior_id]["button_color"]
                    self.main.process_collection.update_many(
                        {"idkey": self.prior_id},
                        {"$unset": {"button_position": "", "button_color": ""}}
                    )
                self.update_button()


            else:
                print("Cancelled")
        except Exception as err:
            print(err)

    def get_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.color = color.name()
            self.update_button()
            self.main.process_data[self.id]["button_color"] = self.color
            self.main.process_collection.update_one(
                {"idkey": self.id},
                {"$set": self.main.process_data[self.id]},
                upsert=True
            )
            return None  # Returns color as hex string, e.g. "#ff0000"
        return None

    def update_button(self):
        self.setText(self.main.process_data[self.id]["title"])
        self.setStyleSheet(f"background-color: {self.color}")
        try:
            self.clicked.disconnect()
        except TypeError:
            # no connections were present
            pass
        self.clicked.connect(lambda: self.main.run_process(self.id))


        #self.layout()


# --- Sub-check widget with simple QCheckBox ---
class Subcheck(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        main_layout = QVBoxLayout(self)

        # Horizontal layout: checkbox + label
        top_row = QHBoxLayout()
        self.check_box = QCheckBox()
        self.check_box.setFixedSize(20, 20)

        self.check_box.stateChanged.connect(self.notify_parent)
        top_row.addWidget(self.check_box)

        self.check_label = QLabel("Check item:")
        self.check_label.setStyleSheet("font-size: 14pt;")
        self.check_box.setStyleSheet("""
            QCheckBox::indicator {
                width: 28px;
                height: 28px;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;  /* Green */
                border: 1px solid #388E3C;
            }
            QCheckBox::indicator:unchecked {
                background-color: white;
                border: 1px solid #888;
            }
        """)
        self.check_label.setAlignment(Qt.AlignVCenter | Qt.AlignLeft)
        top_row.addWidget(self.check_label)

        top_row.addStretch()
        main_layout.addLayout(top_row)

        # Optional comment input
        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        main_layout.addWidget(self.comment_input)



    def notify_parent(self):
        if self.parent() and hasattr(self.parent(), "evaluate_progress"):
            self.parent().evaluate_progress()

    def get_data(self):
        return {
            "text": self.check_label.text(),
            "checked": self.check_box.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_box.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_box.setChecked(False)
        self.comment_input.clear()

# --- Checklist Manager Widget ---
class ChecklistManagerWidget(QWidget):
    def __init__(self, multicheck_input=None):
        super().__init__()
        self.setWindowTitle("Checklist Manager")
        self.setMinimumSize(400, 500)
        self.checks = []

        self.layout = QVBoxLayout(self)

        # Label to show current checklist title or prompt
        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        self.layout.addWidget(self.check_label)

        # Input area with button to add new check item
        add_layout = QHBoxLayout()
        self.check_input = QLineEdit()
        self.check_input.setPlaceholderText("Enter new check...")
        self.add_button = QPushButton("Add Check")
        self.add_button.clicked.connect(self.add_check)
        add_layout.addWidget(self.check_input)
        add_layout.addWidget(self.add_button)
        self.layout.addLayout(add_layout)

        # Scrollable container for check items (Subcheck widgets)
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.checks_container = QWidget()
        self.checks_layout = QVBoxLayout(self.checks_container)
        self.scroll_area.setWidget(self.checks_container)
        self.layout.addWidget(self.scroll_area)

        # Shortcuts for focusing input and confirming add
        focus_shortcut = QShortcut(QKeySequence("Alt+A"), self)
        focus_shortcut.activated.connect(self.check_input.setFocus)

        confirm_shortcut = QShortcut(QKeySequence("Alt+Return"), self)
        confirm_shortcut.activated.connect(self.add_check)

        # Add keyboard shortcut: Ctrl+Shift+C
        self.shortcut_check_first_unchecked = QShortcut(QKeySequence("Ctrl+Shift+C"), self)
        self.shortcut_check_first_unchecked.activated.connect(self.check_first_unchecked)

    def check_first_unchecked(self):
        for subcheck in self.checks:
            if not subcheck.check_box.isChecked():
                subcheck.check_box.setChecked(True)
                break

    def add_check(self):
        """
        Adds a new check item to the checklist if input text is not empty.
        Prevents adding empty or whitespace-only checks.
        """
        text = self.check_input.text()
        if text is None:
            # Defensive: text should not be None, but handle gracefully
            return
        text = text.strip()
        if not text:
            # Do not add empty checks
            return

        # Create new Subcheck widget and set its text safely
        try:
            widget = Subcheck(self.checks_container)
            if hasattr(widget, "set_check_text"):
                widget.set_check_text(text)
            else:
                # Defensive fallback: if Subcheck lacks method, skip adding
                return
        except Exception as e:
            print(f"Error creating or setting Subcheck widget: {e}")
            return

        # Add widget to layout and tracking list
        self.checks_layout.addWidget(widget)
        self.checks.append(widget)

        # Clear input field after adding
        self.check_input.clear()

        # Optionally, update validation state
        self.is_valid()

    def is_valid(self):
        """
        Returns True if all check widgets are valid.
        Empty checklist is considered valid by design.
        """
        if not self.checks:
            return True
        try:
            # Ensure all check widgets implement is_valid method and return True
            return all(
                (hasattr(check, "is_valid") and callable(check.is_valid) and check.is_valid())
                for check in self.checks
            )
        except Exception as e:
            print(f"Error validating checks: {e}")
            return False

    def get_data(self):
        """
        Returns a list of data collected from all Subcheck widgets.
        Returns empty list if no checks or on error.
        """
        try:
            return [
                check.get_data() if (hasattr(check, "get_data") and callable(check.get_data)) else None
                for check in self.checks
            ]
        except Exception as e:
            print(f"Error getting data from checks: {e}")
            return []

    def set_check_text(self, text):
        """
        Sets the checklist title or label text.
        """
        if text is None:
            text = ""
        self.check_label.setText(str(text))

    def reset(self):
        """
        Removes all Subcheck widgets and clears the checklist.
        """
        # Remove widgets safely
        for check in self.checks:
            try:
                check.setParent(None)
                check.deleteLater()
            except Exception as e:
                print(f"Error removing check widget: {e}")

        # Clear internal list of check widgets
        self.checks.clear()

        # Clear input text field
        self.check_input.clear()

        # Update layout to reflect changes
        self.checks_layout.update()

    def load_checks(self, checks_list):
        """
        Loads a list of checks into the widget, replacing existing checks.
        Expects checks_list to be a list of strings; ignores invalid data.
        """
        self.reset()

        # Defensive check for input type
        if not isinstance(checks_list, list):
            print("load_checks expects a list of strings")
            return

        # Add each check text safely
        for text in checks_list:
            if not isinstance(text, str):
                # Skip non-string items to avoid errors
                continue
            try:
                widget = Subcheck(self.checks_container)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
                else:
                    continue
                self.checks_layout.addWidget(widget)
                self.checks.append(widget)
            except Exception as e:
                print(f"Error adding Subcheck in load_checks: {e}")



#TODO neuer fenster bestandteil, wo man die einzelnen
#TODO Final View machen, wo alles zusammengefasst wird und eine möglichkeit für ein Exitbriefing gegeben wird

class DoubleClickCheckButton(QPushButton):
    def __init__(self, text=""):
        super().__init__(text)
        self.setCheckable(True)
        self.setMinimumHeight(80)
        self.setStyleSheet("background-color: none")

    def mousePressEvent(self, event: QMouseEvent):
        # Prevent single clicks from toggling
        event.ignore()

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        # Only toggle on double-click
        self.setChecked(not self.isChecked())
        self.update_style()

    def update_style(self):
        if self.isChecked():
            self.setStyleSheet("background-color: lightgreen")
        else:
            self.setStyleSheet("background-color: none")
class QuestionStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.question_label = QLabel("Question goes here")
        self.question_label.setAlignment(Qt.AlignCenter)
        self.question_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.question_label)

        self.answer_input = QLineEdit()
        self.answer_input.setPlaceholderText("Your answer (required)")
        layout.addWidget(self.answer_input)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        self.answer_input.setFocus()

    def get_data(self):
        return {
            "answer": self.answer_input.text().strip(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return bool(self.answer_input.text().strip())

    def set_question_text(self, text):
        self.question_label.setText(text)
        self.answer_input.clear()
        self.comment_input.clear()

class CheckStepWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.check_label = QLabel("Check item:")
        self.check_label.setAlignment(Qt.AlignCenter)
        self.check_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        layout.addWidget(self.check_label)

        self.check_button = DoubleClickCheckButton("Check Off")
        layout.addWidget(self.check_button)

        self.comment_input = QLineEdit()
        self.comment_input.setPlaceholderText("Optional comment")
        layout.addWidget(self.comment_input)

        # Ctrl + Space shortcut to toggle check
        toggle_shortcut = QShortcut(QKeySequence("Ctrl+Space"), self)
        toggle_shortcut.activated.connect(self.toggle_check_button)

    def toggle_check_button(self):
        self.check_button.setChecked(not self.check_button.isChecked())
        self.check_button.update_style()

    def get_data(self):
        return {
            "checked": self.check_button.isChecked(),
            "comment": self.comment_input.text().strip()
        }

    def is_valid(self):
        return self.check_button.isChecked()

    def set_check_text(self, text):
        self.check_label.setText(text)
        self.check_button.setChecked(False)
        self.check_button.update_style()
        self.comment_input.clear()


class RunProcessWidget(QWidget):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.process_id = None
        self.current_index = 0
        self.process_data = None
        self.process_tracking = None
        self.step_widgets = {}

        # === Outer Layout: Main content (left) + Hints (right) ===
        outer_layout = QHBoxLayout(self)
        self.setLayout(outer_layout)

        # === Left Main Content Area ===
        main_layout = QVBoxLayout()
        main_container = QWidget()
        main_container.setLayout(main_layout)
        outer_layout.addWidget(main_container, 3)  # Stretch factor 3 for main area

        self.title_label = QLabel("Run Process")
        self.title_label.setFont(QFont("Arial", 16, QFont.Bold))
        self.title_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.title_label)

        self.sub_label = QLabel("Step will show here")
        self.sub_label.setFont(QFont("Arial", 12))
        self.sub_label.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.sub_label)

        self.step_container = QStackedWidget()
        main_layout.addWidget(self.step_container)

        self.widgets_by_type = {
            "question": QuestionStepWidget(),
            "check": CheckStepWidget(),
            "subcheck": ChecklistManagerWidget(),
            "multicheck": ChecklistManagerWidget()
        }

        for widget in self.widgets_by_type.values():
            self.step_container.addWidget(widget)

        nav_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.cancel_process)
        nav_layout.addWidget(self.cancel_button)

        self.back_button = QPushButton("Back")
        self.back_button.clicked.connect(self.go_back)
        nav_layout.addWidget(self.back_button)

        self.next_button = QPushButton("Next")
        self.next_button.clicked.connect(self.go_next_or_finish)
        nav_layout.addWidget(self.next_button)

        # Add keyboard shortcuts
        QShortcut(QKeySequence("Ctrl+Return"), self, self.next_button.click)
        QShortcut(QKeySequence("Ctrl+Backspace"), self, self.back_button.click)

        main_layout.addLayout(nav_layout)

        # === Right Side: Hints Panel ===
        self.hints_browser = QTextBrowser()
        self.hints_browser.setMinimumWidth(250)
        self.hints_browser.setStyleSheet("background-color: #f7f7f7; padding: 10px; font-size: 11pt;")
        self.hints_browser.setOpenExternalLinks(True)
        outer_layout.addWidget(self.hints_browser, 1)  # Stretch factor 1 for hints

        # Define static hints per step type
        self.hint_texts = {
            "question": "<b>Hint:</b> Read the question carefully before responding.",
            "check": "<b>Hint:</b> Make sure the stated condition is met.",
            "subcheck": "<b>Hint:</b> Check each sub-item after reviewing it.",
            "multicheck": "<b>Hint:</b> Select all applicable items for the current step."
        }

    def update_view(self):
        """
        Update the visible step and display relevant hints.
        Includes extensive safety checks.
        """
        steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
        if not steps or not isinstance(steps, list) or not (0 <= self.current_index < len(steps)):
            return

        current_step = steps[self.current_index]
        if not isinstance(current_step, dict):
            return

        step_type = current_step.get("type")
        text = current_step.get("text", "No text")

        self.sub_label.setText(f"Step {self.current_index + 1} of {len(steps)}")

        widget = self.widgets_by_type.get(step_type)
        if not widget:
            return

        try:
            if step_type == "question" and hasattr(widget, "set_question_text"):
                widget.set_question_text(text)
            elif step_type == "check" and hasattr(widget, "set_check_text"):
                widget.set_check_text(text)
            elif step_type == "subcheck":
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
                if hasattr(widget, "reset"):
                    widget.reset()
            elif step_type == "multicheck":
                items = current_step.get("items", [])
                if not isinstance(items, list):
                    items = []
                if hasattr(widget, "load_checks"):
                    widget.load_checks(items)
                if hasattr(widget, "set_check_text"):
                    widget.set_check_text(text)
        except Exception as e:
            print(f"Error updating widget: {e}")
            return

        self.step_container.setCurrentWidget(widget)

        # --- Dynamic hint update ---
        hints = current_step.get("hints")
        if isinstance(hints, list) and hints:
            # Join each hint line as a separate bullet point or paragraph
            html = "<b>Hints:</b><br>" + "<br>".join(f"&bull; {line}" for line in hints)
        elif isinstance(hints, str) and hints.strip():
            html = f"<b>Hint:</b> {hints.strip()}"
        else:
            # Fallback to static hints
            html = self.hint_texts.get(step_type, "<i>No hints for this step.</i>")

        self.hints_browser.setHtml(html)

    def go_next_or_finish(self):
        """
        Validate current step, store result, and advance to next or finish.
        """
        steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
        if not steps or not (0 <= self.current_index < len(steps)):
            print("Invalid process state.")
            return

        current_step = steps[self.current_index]
        if not isinstance(current_step, dict):
            print("Malformed step.")
            return

        step_type = current_step.get("type")
        widget = self.widgets_by_type.get(step_type)
        if not widget or not callable(getattr(widget, "is_valid", None)) or not widget.is_valid():
            print("Invalid input for current step.")
            return

        if self.process_tracking is None:
            self.process_tracking = {"responses": []}

        try:
            data = widget.get_data() if callable(getattr(widget, "get_data", None)) else None
        except Exception as e:
            print(f"Error retrieving widget data: {e}")
            return

        self.process_tracking["responses"].append({
            "step": self.current_index,
            "type": step_type or "",
            "data": data
        })

        self.current_index += 1

        if self.current_index < len(steps):
            self.update_view()
        else:
            # Finalize process
            self.process_tracking["status"] = "Completed"
            self.process_tracking["end_time"] = datetime.now()
            self.process_tracking["complete"] = True
            try:
                if hasattr(self.main, "answer_collection"):
                    self.main.answer_collection.insert_one(self.process_tracking)
            except Exception as e:
                print(f"Error saving to DB: {e}")

            try:
                if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
                    self.main.stacked.setCurrentWidget(self.main.grid_widget)
            except Exception as e:
                print(f"Error switching to grid widget: {e}")

    def go_next_or_finish(self):
        steps = self.process_data.get("sub_process_data") if isinstance(self.process_data, dict) else None
        if not steps or not (0 <= self.current_index < len(steps)):
            print("Invalid process state.")
            return

        current_step = steps[self.current_index]
        if not isinstance(current_step, dict):
            print("Malformed step.")
            return

        step_type = current_step.get("type")
        widget = self.widgets_by_type.get(step_type)
        if not widget or not callable(getattr(widget, "is_valid", None)) or not widget.is_valid():
            print("Invalid input for current step.")
            return

        if self.process_tracking is None:
            self.process_tracking = {"responses": []}

        try:
            data = widget.get_data() if callable(getattr(widget, "get_data", None)) else None
        except Exception as e:
            print(f"Error retrieving widget data: {e}")
            return

        # Prepare the new response for this step
        new_response = {
            "step": self.current_index,
            "type": step_type or "",
            "data": data
        }

        responses = self.process_tracking.get("responses", [])

        # Find existing response index for this step, if any
        existing_idx = next((i for i, r in enumerate(responses) if r.get("step") == self.current_index), None)

        if existing_idx is not None:
            responses[existing_idx] = new_response
        else:
            responses.append(new_response)

        self.process_tracking["responses"] = responses

        # Save or update the process tracking document in MongoDB
        try:
            if hasattr(self.main, "answer_collection"):
                if "_id" in self.process_tracking:
                    # Update existing document
                    self.main.answer_collection.update_one(
                        {"_id": self.process_tracking["_id"]},
                        {"$set": {
                            "responses": self.process_tracking["responses"],
                            "status": self.process_tracking.get("status", ""),
                            "complete": self.process_tracking.get("complete", False),
                            "end_time": self.process_tracking.get("end_time", None)
                        }}
                    )
                else:
                    # Insert new document and store the inserted ID
                    result = self.main.answer_collection.insert_one(self.process_tracking)
                    self.process_tracking["_id"] = result.inserted_id
        except Exception as e:
            print(f"Error saving to DB: {e}")

        self.current_index += 1

        if self.current_index < len(steps):
            self.update_view()
        else:
            # Finalize process
            self.process_tracking["status"] = "Completed"
            self.process_tracking["end_time"] = datetime.now()
            self.process_tracking["complete"] = True

            # Save final state to DB again
            try:
                if hasattr(self.main, "answer_collection") and "_id" in self.process_tracking:
                    self.main.answer_collection.update_one(
                        {"_id": self.process_tracking["_id"]},
                        {"$set": {
                            "status": self.process_tracking["status"],
                            "end_time": self.process_tracking["end_time"],
                            "complete": True,
                            "responses": self.process_tracking["responses"]
                        }}
                    )
            except Exception as e:
                print(f"Error saving final state to DB: {e}")

            try:
                if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
                    self.main.stacked.setCurrentWidget(self.main.grid_widget)
            except Exception as e:
                print(f"Error switching to grid widget: {e}")
        self.main.populate_load_table()
    def go_back(self):
        """Move back one step if possible."""
        if self.current_index > 0:
            self.current_index -= 1
            self.update_view()

    def cancel_process(self):
        """Cancel the process and record status."""
        if self.process_tracking is not None:
            self.process_tracking["status"] = "Cancelled"
            self.process_tracking["end_time"] = datetime.now()

            try:
                if hasattr(self.main, "answer_collection"):
                    if "_id" in self.process_tracking:
                        update_data = self.process_tracking.copy()
                        update_data.pop("_id")
                        self.main.answer_collection.update_one(
                            {"_id": self.process_tracking["_id"]},
                            {"$set": update_data}
                        )
                    else:
                        result = self.main.answer_collection.insert_one(self.process_tracking)
                        self.process_tracking["_id"] = result.inserted_id
            except Exception as e:
                print(f"Error saving cancellation data: {e}")

        self.process_id = None
        self.process_tracking = None

        try:
            if hasattr(self.main, "stacked") and hasattr(self.main, "grid_widget"):
                self.main.stacked.setCurrentWidget(self.main.grid_widget)
        except Exception as e:
            print(f"Error switching UI on cancel: {e}")


    def start_process(self, process_data):
        """Initialize a new process with the provided process_data dict."""
        if not isinstance(process_data, dict):
            print("start_process: Invalid input.")
            return

        self.process_data = process_data
        self.current_index = 0
        self.process_tracking = {
            "start_time": datetime.now(),
            "title": process_data.get("title", "Untitled"),
            "process_type_id" : process_data.get("process_id", "unknown key"),
            "responses": [],
            "complete": False
        }

        self.update_view()

    def load_process(self,process_tracking):
        process_loaded_type_id = process_tracking.get("process_type_id","unknown")


        self.process_data = self.main.process_data[process_loaded_type_id]
        self.process_tracking = process_tracking
        self.current_index = len(process_tracking.get("responses", []))  # e.g. resume from last response

        self.update_view()

class MainGridWidget(QWidget):
    def __init__(self,main):
        super().__init__()
        self.layout = QGridLayout(self)
        self.main = main
        self.populate_grid()

    def populate_grid(self):
        print(self.main.process_data)
        for i in range(5):
            for j in range(5):
                button_id = None  # Reset at the start of each grid cell
                color = None
                for key, subdict in self.main.process_data.items():
                    if subdict.get("button_position") == [i, j]:
                        button_id = key
                        color = subdict.get("button_color")
                        break  # Stop after finding the first match

                button = RightClickableButton(self.main, (i, j), load_color=color, load_id = button_id)
                self.layout.addWidget(button, i, j)



class AddSubDialog(QDialog):
    def __init__(self, parent=None, edit=None):
        super().__init__(parent)
        self.setWindowTitle("Add New Sub")
        self.setModal(True)
        self.setMinimumWidth(300)
        self.edit = edit  # Optional dict for editing an existing step

        layout = QVBoxLayout(self)

        # --- Type selection combo box ---
        layout.addWidget(QLabel("Sub Type:"))
        self.type_combo = QComboBox()
        self.type_combo.addItems(["question", "check", "subcheck", "multicheck"])
        layout.addWidget(self.type_combo)

        # --- Dynamic container for input fields ---
        self.input_container = QVBoxLayout()
        layout.addLayout(self.input_container)

        # --- OK / Cancel Buttons ---
        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancel")
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)

        # Signal connections
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.ok_button.setEnabled(False)  # Disabled until input is valid

        if edit:
            type_str = edit.get("type", "")
            index = self.type_combo.findText(type_str, Qt.MatchFixedString)
            self.type_combo.setCurrentIndex(index if index >= 0 else 0)
        else:
            self.type_combo.setCurrentIndex(0)

        self.type_combo.currentIndexChanged.connect(self.rebuild_entry)

        self.rebuild_entry()

        if edit:
            QTimer.singleShot(0, self.prefill_edit)

    def prefill_edit(self):
        subtype = self.type_combo.currentText()
        text = self.edit.get("text", "")

        if subtype == "multicheck":
            title = self.edit.get("text", "")
            items = self.edit.get("items", [])
            if self.text_title:
                self.text_title.setText(title)
            if self.text_widget and isinstance(items, list):
                self.text_widget.setPlainText("\n".join(items))
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit) and isinstance(text, str):
                self.text_widget.setText(text)

        # --- Prefill hint field if available ---
        hints = self.edit.get("hints", [])
        if isinstance(hints, list) and self.hint_widget:
            self.hint_widget.setPlainText("\n".join(hints))

    def validate_input(self):
        subtype = self.type_combo.currentText()
        valid = False

        if subtype == "multicheck":
            if self.text_title and self.text_widget:
                valid = bool(self.text_title.text().strip() and self.text_widget.toPlainText().strip())
        else:
            if self.text_widget and isinstance(self.text_widget, QLineEdit):
                valid = bool(self.text_widget.text().strip())

        self.ok_button.setEnabled(valid)

    def get_data(self):
        subtype = self.type_combo.currentText()

        # Parse hints from QTextEdit into list of trimmed non-empty lines
        hints = []
        if self.hint_widget:
            hints = [
                line.strip() for line in self.hint_widget.toPlainText().splitlines() if line.strip()
            ]

        if subtype == "multicheck":
            if not self.text_title or not self.text_widget:
                return {"type": subtype, "text": "", "items": [], "hints": hints}
            title = self.text_title.text().strip()
            items = [
                line.strip() for line in self.text_widget.toPlainText().splitlines() if line.strip()
            ]
            return {
                "type": subtype,
                "text": title,
                "items": items,
                "hints": hints
            }
        else:
            text = self.text_widget.text().strip() if self.text_widget else ""
            return {
                "type": subtype,
                "text": text,
                "hints": hints
            }

    def rebuild_entry(self):
        # Clear all widgets from the input container
        for i in reversed(range(self.input_container.count())):
            widget = self.input_container.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # Reset references
        self.text_widget = None
        self.text_title = None
        self.hint_widget = None

        subtype = self.type_combo.currentText()

        if subtype == "multicheck":
            self.input_container.addWidget(QLabel("Checklist Title:"))
            self.text_title = QLineEdit()
            self.text_title.setPlaceholderText("Enter checklist title...")
            self.input_container.addWidget(self.text_title)

            self.input_container.addWidget(QLabel("Checklist Items:"))
            self.text_widget = QTextEdit()
            self.text_widget.setPlaceholderText("Enter multiple options, one per line...")
            self.input_container.addWidget(self.text_widget)

            self.text_title.textChanged.connect(self.validate_input)
            self.text_widget.textChanged.connect(self.validate_input)
        else:
            self.input_container.addWidget(QLabel("Text:"))
            self.text_widget = QLineEdit()
            self.text_widget.setPlaceholderText("Enter sub-process text...")
            self.input_container.addWidget(self.text_widget)
            self.text_widget.textChanged.connect(self.validate_input)

        # --- Add hint input field for all types ---
        self.input_container.addWidget(QLabel("Hints (one per line):"))
        self.hint_widget = QTextEdit()
        self.hint_widget.setPlaceholderText("Enter optional hints for this step...")
        self.input_container.addWidget(self.hint_widget)

        self.validate_input()
class EditProcessesWidget(QWidget):
    def __init__(self, main):
        super().__init__()

        self.main = main

        # Main layout
        main_layout = QVBoxLayout(self)

        # Header label styled as a header
        header = QLabel("Edit Processes View")
        header.setFont(QFont("Arial", 16, QFont.Bold))
        header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(header)

        # Horizontal layout: list on left, buttons on right
        content_layout = QHBoxLayout()

        # Left side: process list (single-select)
        self.process_list = QListWidget()
        self.process_list.setSelectionMode(QListWidget.SingleSelection)
        for key in self.main.process_data.keys():
            list_item = QListWidgetItem(self.main.process_data[key]["title"])  # show only the title
            list_item.setData(Qt.UserRole, key)  # store full dict
            self.process_list.addItem(list_item)
        content_layout.addWidget(self.process_list)

        # Right side: buttons
        button_layout = QVBoxLayout()

        self.run_button = QPushButton("Run")
        self.run_button.clicked.connect(self.run_process)
        button_layout.addWidget(self.run_button)

        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self.add_process)
        button_layout.addWidget(self.add_button)

        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self.edit_process)
        button_layout.addWidget(self.edit_button)

        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_process)
        button_layout.addWidget(self.delete_button)

        content_layout.addLayout(button_layout)

        # Add content to main layout
        main_layout.addLayout(content_layout)

    # === Button Handlers ===
    def run_process(self):
        selected_item = self.process_list.currentItem()
        if selected_item is None:
            QMessageBox.warning(self, "No Selection", "Please select a process to run.")
            return

        process_id = selected_item.data(Qt.UserRole)
        self.main.run_process(process_id)

    def add_process(self):
        try:
            self.main.stacked.setCurrentWidget(self.main.new_widget)
            self.main.new_widget.process_id = str(uuid.uuid4())
            self.main.process_data[self.main.new_widget.process_id] = {"process_id":self.main.new_widget.process_id,"title":"new process","sub_process_data":[]}
            print(self.main.process_data)
        except Exception as err:
            print(888, str(err))

    def edit_process(self):

        selected_item = self.process_list.currentItem()
        process_id = selected_item.data(Qt.UserRole)
        self.process_id = process_id
        self.main.new_widget.process_id = self.process_id
        self.main.stacked.setCurrentWidget(self.main.new_widget)
        self.main.new_widget.title_input.setText(self.main.process_data[self.process_id]["title"])
        self.main.new_widget.subs_list.clear()
        for entry in self.main.process_data[self.process_id]["sub_process_data"]:
            self.main.new_widget.subs_list.addItem(str(entry))

        if not self.process_id:
            print("No process selected for editing.")
            return

        # Get the stored process ID from the item




    def delete_process(self):
        print("Delete")

class NewProcessWidget(QWidget):
    def __init__(self, main):
        super().__init__()

        if not hasattr(self, 'process_id'):
            self.process_id = None

        self.main = main  # reference to main window

        main_layout = QVBoxLayout(self)

        # Header
        self.header = QLabel("New Process View")
        self.header.setFont(QFont("Arial", 16, QFont.Bold))
        self.header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(self.header)

        # Title input + confirm button in a row
        title_row = QHBoxLayout()
        title_label = QLabel("Title:")
        self.title_input = QLineEdit()
        confirm_title_button = QPushButton("Confirm Title")
        confirm_title_button.clicked.connect(self.confirm_title)
        title_row.addWidget(title_label)
        title_row.addWidget(self.title_input)
        title_row.addWidget(confirm_title_button)
        main_layout.addLayout(title_row)

        # Horizontal layout: subs list on left, buttons on right
        content_layout = QHBoxLayout()

        # Sub-processes list
        subs_layout = QVBoxLayout()
        subs_label = QLabel("Sub-Processes:")
        subs_layout.addWidget(subs_label)

        self.subs_list = QListWidget()
        self.subs_list.setSelectionMode(QListWidget.SingleSelection)
        subs_layout.addWidget(self.subs_list)
        content_layout.addLayout(subs_layout)

        # Buttons layout (vertical)
        button_layout = QVBoxLayout()
        buttons = [
            ("Add", self.add_clicked),
            ("Edit", self.edit_clicked),
            ("Delete", self.delete_clicked),
            ("Up", self.up_clicked),
            ("Down", self.down_clicked),
        ]

        for text, handler in buttons:
            btn = QPushButton(text)
            btn.clicked.connect(handler)
            button_layout.addWidget(btn)

        button_layout.addStretch()  # push buttons to top
        content_layout.addLayout(button_layout)

        main_layout.addLayout(content_layout)

        # Bottom buttons: Cancel and Confirm
        bottom_buttons_layout = QHBoxLayout()
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.cancel_clicked)
        bottom_buttons_layout.addWidget(cancel_button)

        confirm_button = QPushButton("Confirm")
        confirm_button.clicked.connect(self.confirm_clicked)
        bottom_buttons_layout.addWidget(confirm_button)

        main_layout.addLayout(bottom_buttons_layout)

    # Button handlers (just print labels)

    def confirm_title(self):
        title = self.title_input.text()
        self.header.setText(title if title else "New Process View")
        self.main.process_data[self.process_id]["title"] = title
        self.main.save_process_to_mdb(self.process_id)

    def add_clicked(self):
        dialog = AddSubDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()
            self.main.process_data[self.process_id]["sub_process_data"].append(data)
            self.main.save_process_to_mdb(self.process_id)
            # self.temp["questions"] = self.temp["questions"] + [data]
            self.subs_list.clear()
            for entry in self.main.process_data[self.process_id]["sub_process_data"]:
                 self.subs_list.addItem(str(entry))

    def edit_clicked(self):
        selected_item = self.subs_list.currentItem()
        selected_index = self.subs_list.currentRow()
        d = ast.literal_eval(selected_item.text())
        dialog = AddSubDialog(self,edit = d)
        if dialog.exec_() == QDialog.Accepted:
            data = dialog.get_data()
            self.main.process_data[self.process_id]["sub_process_data"][selected_index] = data
            self.main.save_process_to_mdb(self.process_id)
            self.subs_list.clear()
            for entry in self.main.process_data[self.process_id]["sub_process_data"]:
                 self.subs_list.addItem(str(entry))



    def delete_clicked(self):
        print("Delete")

    def up_clicked(self):
        try:
            index = self.subs_list.currentRow()
            if index > 0:
                data = self.main.process_data[self.process_id]["sub_process_data"]
                data[index - 1], data[index] = data[index], data[index - 1]
                self.main.save_process_to_mdb(self.process_id)
                self.refresh_subs_list()
                self.subs_list.setCurrentRow(index - 1)
        except Exception as err:
            print(str(err))

    def down_clicked(self):
        index = self.subs_list.currentRow()
        data = self.main.process_data[self.process_id]["sub_process_data"]
        if 0 <= index < len(data) - 1:
            data[index + 1], data[index] = data[index], data[index + 1]
            self.main.save_process_to_mdb(self.process_id)
            self.refresh_subs_list()
            self.subs_list.setCurrentRow(index + 1)

    def refresh_subs_list(self):
        self.subs_list.clear()
        for entry in self.main.process_data[self.process_id]["sub_process_data"]:
            self.subs_list.addItem(str(entry))

    def cancel_clicked(self):
        # Switch back to edit processes widget
        self.main.stacked.setCurrentWidget(self.main.edit_widget)

        # Reset UI in NewProcessWidget
        self.main.new_widget.title_input.clear()
        self.main.new_widget.header.setText("New Process View")
        self.main.new_widget.subs_list.clear()

    def delete_clicked(self):
        selected_index = self.subs_list.currentRow()
        if selected_index >= 0:
            del self.main.process_data[self.process_id]["sub_process_data"][selected_index]
            self.main.save_process_to_mdb(self.process_id)
            self.subs_list.takeItem(selected_index)

    def confirm_clicked(self):
        title = self.title_input.text()
        subs = [self.subs_list.item(i).text() for i in range(self.subs_list.count())]

        print(f"Saving process with title: {title}")
        print("Sub-processes:", subs)

        self.main.edit_widget.process_list.clear()
        for key in self.main.process_data.keys():
            list_item = QListWidgetItem(self.main.process_data[key]["title"])  # show only the title
            list_item.setData(Qt.UserRole, key)  # store full dict
            self.main.edit_widget.process_list.addItem(list_item)

        # Reset UI in NewProcessWidget
        self.main.new_widget.title_input.clear()
        self.main.new_widget.header.setText("New Process View")
        self.main.new_widget.subs_list.clear()

        # Switch back to edit processes widget
        self.main.stacked.setCurrentWidget(self.main.edit_widget)
        self.main.save_process_to_mdb(self.process_id)

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Process Manager")
        self.resize(800, 600)


        self.uri = uri


        main_layout = QVBoxLayout(self)

        # init mongo connection
        client = MongoClient(self.uri)
        db = client["process_tool"]
        self.answer_collection = db["processes_completed"]
        self.answer_collection.insert_one({"title":"connection","time":datetime.now()})
        self.process_collection = db["processes"]

        self.process_data = {
            doc["idkey"]: doc
            for doc in self.process_collection.find()
            if "idkey" in doc  # optional safety check
        }

        # Top buttons (only 3 now)
        button_layout = QHBoxLayout()
        self.run_button = QPushButton("Run")
        self.grid_button = QPushButton("Main Grid")
        self.edit_button = QPushButton("Edit Processes")

        for btn in (self.grid_button, self.edit_button):
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # Stacked widget setup
        self.stacked = QStackedWidget()
        self.run_widget = RunProcessWidget(self)
        self.grid_widget = MainGridWidget(self)
        self.edit_widget = EditProcessesWidget(self)
        self.new_widget = NewProcessWidget(self)  # Still available if needed

        self.stacked.addWidget(self.run_widget)
        self.stacked.addWidget(self.grid_widget)
        self.stacked.addWidget(self.edit_widget)
        self.stacked.addWidget(self.new_widget)

        main_layout.addWidget(self.stacked)

        # Connect buttons to view changes
        self.run_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.run_widget))
        self.grid_button.clicked.connect(self.return_to_main)
        self.edit_button.clicked.connect(lambda: self.stacked.setCurrentWidget(self.edit_widget))

        # Default view
        self.stacked.setCurrentWidget(self.grid_widget)

        self.save_and_load_widget = QTableWidget()

        main_layout.addWidget(self.save_and_load_widget)

        self.stacked.currentChanged.connect(self.populate_load_table)

        # Enable custom context menu
        self.save_and_load_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.save_and_load_widget.customContextMenuRequested.connect(self.open_menu)
        self.save_and_load_widget.cellDoubleClicked.connect(self.load_on_double_click)

        self.populate_load_table()


    def return_to_main(self):
        self.stacked.setCurrentWidget(self.grid_widget)
        try:
            if hasattr(self, "answer_collection"):
                self.answer_collection.insert_one(self.run_widget.process_tracking)
        except Exception as e:
            print(f"Error saving cancellation data: {e}")


    def save_process_to_mdb(self, id):
        self.process_collection.update_one(
            {"idkey": id},
            {"$set": self.process_data[id]},
            upsert=True
        )

    def load_on_double_click(self, row, column):
        item  = self.save_and_load_widget.item(row,0)
        mongo_id = ObjectId(item.data(Qt.UserRole))
        temp_status = self.answer_collection.find_one({'_id': mongo_id})
        self.run_widget.load_process(temp_status)
        self.stacked.setCurrentWidget(self.run_widget)

        print(temp_status)
        #self.run_widget.start_process(self.process_data[id])


    def open_menu(self, position: QPoint):
        index = self.save_and_load_widget.indexAt(position)
        if not index.isValid():
            return

        row = index.row()
        process_name = self.save_and_load_widget.item(row, 0).text()  # Adjust if your "process" column is elsewhere

        menu = QMenu()
        action_kill = QAction(f"Kill process '{process_name}'", self)
        action_details = QAction("View Details", self)

        action_kill.triggered.connect(lambda: self.kill_process(row))
        action_details.triggered.connect(lambda: self.view_details(row))

        menu.addAction(action_kill)
        menu.addAction(action_details)
        menu.exec_(self.save_and_load_widget.viewport().mapToGlobal(position))

    def kill_process(self, row):
        try:
            process_name = self.save_and_load_widget.item(row, 0).text()  # Adjust column index if needed
            pid = self.save_and_load_widget.item(row, 1).text()  # Assuming PID is in column 1
            item = self.save_and_load_widget.item(row, 0)  # or any item in the row
            mongo_id =  ObjectId(item.data(Qt.UserRole))
            print(mongo_id)
            reply = QMessageBox.question(
                self,
                "Confirm Kill",
                f"Are you sure you want to kill process '{process_name}' (PID {pid})?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                self.run_widget.cancel_process()
                self.answer_collection.update_one(
                    {"_id": mongo_id},  # or another unique filter
                    {
                        "$set": {
                            "complete": True,
                            "status": "deleted"
                        }
                    }
                )
                self.populate_load_table()

                #return to main widget

            else:
                print("Kill cancelled.")
        except Exception as err:
            print(err)

    def view_details(self, row):
        print(f"View details for row {row}")

    def run_process(self,id):
        #print(22,self.process_data[id])
        self.stacked.setCurrentWidget(self.run_widget)
        self.run_widget.start_process(self.process_data[id])

    def populate_load_table(self):
        # Clear existing contents and reset row/column counts
        self.save_and_load_widget.clearContents()
        self.save_and_load_widget.setRowCount(0)
        self.save_and_load_widget.setColumnCount(0)

        query = {
            "complete": False,
            "status": {"$ne": "deleted"}  # Exclude deleted
        }
        results = list(self.answer_collection.find(query))
        print(5555, results)
        if not results:
            return

        # Set row and column counts based on results
        self.save_and_load_widget.setRowCount(len(results))
        # Use keys from first document as column headers (exclude _id if desired)
        keys = list(results[0].keys())
        self.save_and_load_widget.setColumnCount(len(keys))
        self.save_and_load_widget.setHorizontalHeaderLabels(keys)

        # Populate table
        for row, entry in enumerate(results):
            for col, key in enumerate(keys):
                value = entry.get(key, "")
                text = str(value)

                # Create a preview if text is long
                preview = text if len(text) <= 40 else text[:37] + "..."

                item = QTableWidgetItem(preview)
                # Make cell non-editable
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # Tooltip shows full text on hover
                item.setToolTip(text)

                self.save_and_load_widget.setItem(row, col, item)

            # Store the MongoDB _id (as string) in the first column's UserRole data for access later
            id_item = self.save_and_load_widget.item(row, 0)
            if id_item:
                id_item.setData(Qt.UserRole, str(entry.get("_id", "")))

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
